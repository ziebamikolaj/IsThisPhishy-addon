Directory Structure:
--------------------
|-- public
-- src
    |-- background
    |-- components
    |   -- ui
    |-- content
    |-- lib
    |-- popup
    |   |-- components
    |   |-- hooks
    |   |-- services
    |   -- utils
    |-- styles
    -- types
--------------------
File Contents:
--------------------
--------------------
File: C:\Users\mikol\Desktop\IsThisPhishy-addon\.gitignore
--------------------
node_modules

--------------------
File: C:\Users\mikol\Desktop\IsThisPhishy-addon\components.json
--------------------
{
  "$schema": "https://ui.shadcn.com/schema.json",
  "style": "default",
  "rsc": true,
  "tsx": true,
  "tailwind": {
    "config": "tailwind.config.ts",
    "css": "src/app/styles/globals.css",
    "baseColor": "neutral",
    "cssVariables": true,
    "prefix": ""
  },
  "aliases": {
    "components": "@/components",
    "utils": "@/lib/utils",
    "ui": "@/components/ui",
    "lib": "@/lib",
    "hooks": "@/hooks"
  }
}

--------------------
File: C:\Users\mikol\Desktop\IsThisPhishy-addon\eslint.config.js
--------------------
import js from '@eslint/js'
import globals from 'globals'
import reactHooks from 'eslint-plugin-react-hooks'
import reactRefresh from 'eslint-plugin-react-refresh'
import tseslint from 'typescript-eslint'

export default tseslint.config(
  { ignores: ['dist'] },
  {
    extends: [js.configs.recommended, ...tseslint.configs.recommended],
    files: ['**/*.{ts,tsx}'],
    languageOptions: {
      ecmaVersion: 2020,
      globals: globals.browser,
    },
    plugins: {
      'react-hooks': reactHooks,
      'react-refresh': reactRefresh,
    },
    rules: {
      ...reactHooks.configs.recommended.rules,
      'react-refresh/only-export-components': [
        'warn',
        { allowConstantExport: true },
      ],
    },
  },
)

--------------------
File: C:\Users\mikol\Desktop\IsThisPhishy-addon\index.html
--------------------
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <!-- Jeśli masz ikonę specyficzną dla popupu, możesz ją tu dodać -->
    <title>IsThisFishy Popup</title>
    <!-- Plugin powinien automatycznie wstrzyknąć CSS -->
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="./popup.tsx"></script>
    <!-- Wskazuje na plik TSX popupu -->
  </body>
</html>

--------------------
File: C:\Users\mikol\Desktop\IsThisPhishy-addon\package.json
--------------------
{
  "name": "isthisfishy-extension",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "tsc && vite build",
    "preview": "vite preview"
  },
  "dependencies": {
    "@radix-ui/react-progress": "^1.1.0",
    "@radix-ui/react-slot": "^1.1.0",
    "@radix-ui/react-switch": "^1.1.0",
    "@radix-ui/react-tooltip": "^1.1.2",
    "class-variance-authority": "^0.7.0",
    "clsx": "^2.1.1",
    "lucide-react": "^0.446.0",
    "path": "^0.12.7",
    "react": "^18.3.1",
    "react-dom": "^18.3.1",
    "tailwind-merge": "^2.5.2",
    "tailwindcss-animate": "^1.0.7"
  },
  "devDependencies": {
    "@eslint/js": "^9.9.0",
    "@types/chrome": "^0.0.237",
    "@types/react": "^18.3.10",
    "@types/react-dom": "^18.3.0",
    "@vitejs/plugin-react": "^4.3.1",
    "autoprefixer": "^10.4.20",
    "eslint": "^9.9.0",
    "eslint-plugin-react-hooks": "^5.1.0-rc.0",
    "eslint-plugin-react-refresh": "^0.4.9",
    "globals": "^15.9.0",
    "postcss": "^8.4.47",
    "postcss-cli": "^11.0.0",
    "tailwindcss": "^3.4.13",
    "typescript": "^5.6.2",
    "typescript-eslint": "^8.0.1",
    "vite": "^5.4.1",
    "vite-plugin-web-extension": "^4.4.3"
  }
}

--------------------
File: C:\Users\mikol\Desktop\IsThisPhishy-addon\postcss.config.js
--------------------
export default {
  plugins: {
    tailwindcss: {},
    autoprefixer: {},
  },
};

--------------------
File: C:\Users\mikol\Desktop\IsThisPhishy-addon\README.md
--------------------
# Hack yeah 2024 - Is this fishy ?

## Extension:

- Vite
- React
- TypeScript

## Frontend:

- Next.js
- React
- TypeScript
- **Schema validation**
  - Zod
- **Form handling**
  - React Hook Form
- **Query handling**
  - TanStack Query
- **UI**
  - Tailwind CSS
  - shadcn/ui
- **Emails template** (optional)
  - React email

## Backend:

- Next.js API
- Drizzle ORM
- **File hosting** (optional)
  - AWS S3
- **Email sending** (optional)
  - AWS SES
- **Phone notifications** (optional)
  - AWS SNS

--------------------
File: C:\Users\mikol\Desktop\IsThisPhishy-addon\tailwind.config.ts
--------------------
/** @type {import('tailwindcss').Config} */
export default {
  darkMode: ["class"],
  content: ["./src/**/*.{js,jsx,ts,tsx}", "./src/**/*.html"],
  theme: {
    extend: {
      borderRadius: {
        lg: "var(--radius)",
        md: "calc(var(--radius) - 2px)",
        sm: "calc(var(--radius) - 4px)",
      },
      colors: {
        background: "hsl(var(--background))",
        foreground: "hsl(var(--foreground))",
        card: {
          DEFAULT: "hsl(var(--card))",
          foreground: "hsl(var(--card-foreground))",
        },
        popover: {
          DEFAULT: "hsl(var(--popover))",
          foreground: "hsl(var(--popover-foreground))",
        },
        primary: {
          DEFAULT: "hsl(var(--primary))",
          foreground: "hsl(var(--primary-foreground))",
        },
        secondary: {
          DEFAULT: "hsl(var(--secondary))",
          foreground: "hsl(var(--secondary-foreground))",
        },
        muted: {
          DEFAULT: "hsl(var(--muted))",
          foreground: "hsl(var(--muted-foreground))",
        },
        accent: {
          DEFAULT: "hsl(var(--accent))",
          foreground: "hsl(var(--accent-foreground))",
        },
        destructive: {
          DEFAULT: "hsl(var(--destructive))",
          foreground: "hsl(var(--destructive-foreground))",
        },
        border: "hsl(var(--border))",
        input: "hsl(var(--input))",
        ring: "hsl(var(--ring))",
        chart: {
          "1": "hsl(var(--chart-1))",
          "2": "hsl(var(--chart-2))",
          "3": "hsl(var(--chart-3))",
          "4": "hsl(var(--chart-4))",
          "5": "hsl(var(--chart-5))",
        },
      },
    },
  },
  plugins: [import("tailwindcss-animate")],
};

--------------------
File: C:\Users\mikol\Desktop\IsThisPhishy-addon\tsconfig.json
--------------------
{
  "compilerOptions": {
    "target": "ESNext",
    "lib": ["DOM", "DOM.Iterable", "ESNext"],
    "allowJs": true,
    "skipLibCheck": true,
    "esModuleInterop": true,
    "allowSyntheticDefaultImports": true,
    "strict": true,
    "forceConsistentCasingInFileNames": true,
    "module": "ESNext",
    "moduleResolution": "Node",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "noEmit": true,
    "jsx": "react-jsx",
    "baseUrl": ".",
    "paths": {
      "@/*": ["./src/*"]
    }
  },
  "include": ["src"],
  "exclude": ["node_modules", "dist"]
}

--------------------
File: C:\Users\mikol\Desktop\IsThisPhishy-addon\tsconfig.tsbuildinfo
--------------------
{"root":["./src/App.tsx","./src/main.tsx","./src/vite-env.d.ts","./src/background/background.ts","./src/content/content.ts","./src/popup/main.tsx"],"version":"5.6.2"}

--------------------
File: C:\Users\mikol\Desktop\IsThisPhishy-addon\vite.config.ts
--------------------
import { defineConfig } from "vite";
import react from "@vitejs/plugin-react";
import webExtension from "vite-plugin-web-extension";
import path from "node:path";

function generateManifest() {
  return {
    manifest_version: 3,
    name: "IsThisFishy Extension (Dev)",
    version: "1.0.3", // Podbij wersję
    description: "A browser extension to detect fishy content - DEV MODE",
    action: {
      default_popup: "src/popup/index.html",
    },
    background: {
      service_worker: "src/background/background.ts",
      type: "module",
    },
    content_scripts: [
      {
        matches: ["<all_urls>"],
        js: ["src/content/content.ts"],
        // css: ["style.css"], // Upewnij się, że to jest potrzebne lub usuń
      },
    ],
    icons: {
      // Upewnij się, że to jest poprawnie zdefiniowane
      "16": "icon.png",
      "48": "icon.png",
      "128": "icon.png",
    },
    permissions: ["activeTab", "storage", "tabs", "action", "scripting"],
    host_permissions: ["http://127.0.0.1:8000/"],
  };
}

export default defineConfig(({ mode }) => {
  const isDevelopment = mode === "development";
  return {
    plugins: [
      react(),
      webExtension({
        manifest: generateManifest,
        // verbose: true, // Odkomentuj dla debugowania problemów z pluginem
      }),
    ],
    resolve: { alias: { "@": path.resolve(__dirname, "./src") } },
    build: {
      outDir: path.resolve(__dirname, "dist"),
      sourcemap: isDevelopment ? "inline" : false,
      emptyOutDir: true,
    },
    server: { hmr: { protocol: "ws", host: "localhost", port: 5174 } }, // Zmieniono port na domyślny Vite, jeśli nie używasz 5000 specjalnie
  };
});

Skipping binary file: C:\Users\mikol\Desktop\IsThisPhishy-addon\public\icon.png
--------------------
File: C:\Users\mikol\Desktop\IsThisPhishy-addon\src\main.tsx
--------------------
import React from "react";
import ReactDOM from "react-dom/client";

import "./styles/globals.css";

import { PopupContent } from "./popup/popup-content";

ReactDOM.createRoot(document.getElementById("root") as HTMLElement).render(
  <React.StrictMode>
    <PopupContent></PopupContent>
  </React.StrictMode>,
);

--------------------
File: C:\Users\mikol\Desktop\IsThisPhishy-addon\src\vite-env.d.ts
--------------------
/// <reference types="vite/client" />

--------------------
File: C:\Users\mikol\Desktop\IsThisPhishy-addon\src\background\background.ts
--------------------
// src/background/background.ts
import {
  DomainAnalysisDetails,
  PhishingTextAnalysis,
  PageContentAiAnalysis,
  StoredDomainData,
} from "@/types/domainAnalysis";

const API_BASE_URL = "http://127.0.0.1:8000/api/v1";

const getDomainFromUrl = (url: string): string => {
  try {
    const u = new URL(url);
    return u.hostname.replace(/^www\./, "");
  } catch {
    return "";
  }
};
const updateBadge = (text: string, color: string = "#777777") => {
  try {
    chrome.action.setBadgeText({ text });
    chrome.action.setBadgeBackgroundColor({ color });
    console.log(`[BG] Badge updated: text="${text}", color="${color}"`);
  } catch (e) {
    console.warn(
      "[BG] Failed to update badge, extension context likely invalid.",
      e
    );
  }
};

const fetchTextAnalysis = async (
  textToAnalyze: string
): Promise<PhishingTextAnalysis | null> => {
  const textSnippet =
    textToAnalyze.substring(0, 100) + (textToAnalyze.length > 100 ? "..." : "");
  console.log(
    `[BG] fetchTextAnalysis: Attempting to analyze text snippet: "${textSnippet}"`
  );
  try {
    const response = await fetch(`${API_BASE_URL}/check_phishing_text`, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ text_to_analyze: textToAnalyze }),
    });
    if (!response.ok) {
      const errorBody = await response.text().catch(() => "No error body");
      console.error(
        `[BG] fetchTextAnalysis API Error for snippet "${textSnippet}": ${response.status}`,
        errorBody
      );
      return null;
    }
    const data: PhishingTextAnalysis = await response.json();
    console.log(
      `[BG] fetchTextAnalysis API Success for snippet "${textSnippet}":`,
      data
    );
    return data;
  } catch (e) {
    console.error(
      `[BG] fetchTextAnalysis Network Error for snippet "${textSnippet}":`,
      e
    );
    return null;
  }
};

const performFullAnalysis = async (
  urlToAnalyze: string,
  contentChunksToAnalyze?: string[]
): Promise<StoredDomainData> => {
  const domain = getDomainFromUrl(urlToAnalyze);
  if (!domain) {
    console.warn(
      "[BG] performFullAnalysis: Invalid domain from URL:",
      urlToAnalyze
    );
    return { error: "Invalid domain", lastChecked: Date.now() };
  }
  updateBadge("...", "#F59E0B");
  console.log(
    `[BG] Performing full analysis for ${urlToAnalyze}. Content chunks: ${
      contentChunksToAnalyze?.length || 0
    }`
  );

  try {
    const [domainDetailsResponse, urlTextAnalysisResult] = await Promise.all([
      fetch(`${API_BASE_URL}/analyze_domain_details`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ url: urlToAnalyze }),
      }),
      fetchTextAnalysis(urlToAnalyze), // Analiza samego URL
    ]);

    console.log(
      `[BG] performFullAnalysis - URL AI Analysis result for ${urlToAnalyze}:`,
      urlTextAnalysisResult
    );

    if (!domainDetailsResponse.ok) {
      const errorData = await domainDetailsResponse
        .json()
        .catch(() => ({ detail: "Unknown API error (domain)" }));
      updateBadge("!", "#EF4444");
      console.error(`[BG] Domain analysis API Error for ${domain}:`, errorData);
      return {
        error: `API Error (domain):${
          errorData.detail || domainDetailsResponse.statusText
        }`,
        lastChecked: Date.now(),
      };
    }
    const domainAnalysis: DomainAnalysisDetails =
      await domainDetailsResponse.json();
    if (domainAnalysis.error) {
      updateBadge("?", "#EF4444");
      console.warn(
        `[BG] API returned error in domain data for ${domain}:`,
        domainAnalysis.error
      );
      return { error: domainAnalysis.error, lastChecked: Date.now() };
    }
    console.log("[BG] Domain analysis OK for", domain);

    let pageContentAiAnalyses: PageContentAiAnalysis[] | null = null;
    if (contentChunksToAnalyze && contentChunksToAnalyze.length > 0) {
      pageContentAiAnalyses = [];
      console.log(
        `[BG] Analyzing ${contentChunksToAnalyze.length} content chunks for ${domain}`
      );
      const analysisPromises = contentChunksToAnalyze.map(
        async (chunk, idx) => {
          const result = await fetchTextAnalysis(chunk); // Użyj tej samej funkcji
          if (result) {
            pageContentAiAnalyses?.push({
              ...result,
              chunkIndex: idx,
              originalChunk: chunk.substring(0, 100) + "...", // Przechowaj fragment dla debugowania
            });
          } else {
            console.warn(
              `[BG] Failed to analyze content chunk ${idx} for ${domain}`
            );
          }
        }
      );
      await Promise.all(analysisPromises); // Czekaj na wszystkie analizy chunków
      console.log(
        `[BG] pageContentAiAnalyses for ${domain} (count: ${
          pageContentAiAnalyses?.length || 0
        }):`,
        pageContentAiAnalyses
      );
    } else {
      console.log(`[BG] No content chunks to analyze for ${domain}`);
      pageContentAiAnalyses = []; // Ustaw pustą tablicę, jeśli nie ma chunków, zamiast null
    }

    const storedData: StoredDomainData = {
      analysis: domainAnalysis,
      urlTextAnalysis: urlTextAnalysisResult,
      pageContentAnalyses: pageContentAiAnalyses,
      lastChecked: Date.now(),
    };
    console.log(
      "[BG] StoredData to be saved for",
      domain,
      ":",
      JSON.parse(JSON.stringify(storedData))
    );
    chrome.storage.local.set({ [domain]: storedData });
    return storedData;
  } catch (e) {
    updateBadge("!", "#EF4444");
    const errorMsg = e instanceof Error ? e.message : String(e);
    console.error(
      `[BG] Network/Parsing Error in performFullAnalysis for ${domain}: ${errorMsg}`
    );
    return {
      error: `Network/Parsing error: ${errorMsg}`,
      lastChecked: Date.now(),
    };
  }
};

const triggerAnalysisForUrl = async (
  url: string,
  forceContentFetch: boolean = false,
  tabIdForContent?: number // Opcjonalny tabId
) => {
  const domain = getDomainFromUrl(url);
  if (!domain) {
    console.warn("[BG] triggerAnalysis: No domain for URL", url);
    return;
  }

  console.log(
    `[BG] triggerAnalysisForUrl: ${url}, forceContentFetch: ${forceContentFetch}, tabIdForContent: ${tabIdForContent}`
  );

  if (forceContentFetch && tabIdForContent) {
    console.log(
      "[BG] Requesting text from page:",
      url,
      "Tab ID:",
      tabIdForContent
    );
    chrome.tabs.sendMessage(
      tabIdForContent,
      { action: "getTextContentFromPage" },
      (responseFromContent) => {
        // Ta odpowiedź jest z content.ts
        if (chrome.runtime.lastError) {
          console.warn(
            `[BG] Error sending to content script for ${url} (tab ${tabIdForContent}): ${chrome.runtime.lastError.message}. Proceeding with URL-only analysis.`
          );
          performFullAnalysis(url, []).then((data) => {
            // Przekaż puste chunki
            chrome.runtime
              .sendMessage({
                action: "analysisUpdated",
                domain,
                data,
                forUrl: url,
              })
              .catch((e) =>
                console.warn(
                  "[BG] Error sending analysisUpdated (no content fetch response):",
                  e.message
                )
              );
          });
        } else if (responseFromContent?.status?.includes("processing")) {
          console.log("[BG] Content script started processing text for:", url);
          // Czekamy, aż content script wyśle 'analyzePageContent'
        } else {
          console.warn(
            "[BG] Content script for",
            url,
            "responded unexpectedly or failed to start:",
            responseFromContent,
            ". Proceeding with URL-only analysis."
          );
          performFullAnalysis(url, []).then((data) => {
            // Przekaż puste chunki
            chrome.runtime
              .sendMessage({
                action: "analysisUpdated",
                domain,
                data,
                forUrl: url,
              })
              .catch((e) =>
                console.warn(
                  "[BG] Error sending analysisUpdated (unexpected content response):",
                  e.message
                )
              );
          });
        }
      }
    );
  } else {
    // Nie wymuszamy pobierania treści z content.ts
    console.log(
      `[BG] Performing analysis for ${domain} (no force content fetch, using existing/URL only).`
    );
    chrome.storage.local.get(domain, (result) => {
      const cachedData: StoredDomainData | undefined = result[domain];
      const fiveMinutes = 5 * 60 * 1000;
      if (
        cachedData?.analysis && // Upewnij się, że główne dane są
        Date.now() - cachedData.lastChecked < fiveMinutes &&
        typeof cachedData.urlTextAnalysis !== "undefined" && // Sprawdź czy urlTextAnalysis było zrobione
        typeof cachedData.pageContentAnalyses !== "undefined" && // I czy pageContentAnalyses było zrobione (może być puste)
        !cachedData.error // I czy nie ma zapisanego błędu
      ) {
        console.log(
          "[BG] Using cached data for (no force content fetch):",
          domain
        );
        chrome.runtime
          .sendMessage({
            action: "analysisUpdated",
            domain,
            data: cachedData,
            forUrl: url,
          })
          .catch((e) =>
            console.warn(
              "[BG] Error sending analysisUpdated (cache):",
              e.message
            )
          );
      } else {
        console.log(
          "[BG] Cache miss/incomplete/error. Performing analysis with URL only for:",
          url
        );
        performFullAnalysis(url, cachedData?.pageContentAnalyses || []).then(
          (data) => {
            // Przekaż istniejące pageContentAnalyses jeśli są, inaczej puste
            chrome.runtime
              .sendMessage({
                action: "analysisUpdated",
                domain,
                data,
                forUrl: url,
              })
              .catch((e) =>
                console.warn(
                  "[BG] Error sending analysisUpdated (no cache/no force):",
                  e.message
                )
              );
          }
        );
      }
    });
  }
};

const handleTabUpdate = async (url: string | undefined, tabId?: number) => {
  if (url && (url.startsWith("http:") || url.startsWith("https:"))) {
    console.log(`[BG] handleTabUpdate for URL: ${url}, TabID: ${tabId}`);
    triggerAnalysisForUrl(url, false, tabId); // Domyślnie nie wymuszaj, ale przekaż tabId
  } else {
    console.log(
      `[BG] handleTabUpdate: Skipped (not http/https or no URL): ${url}`
    );
    updateBadge("", "#777777");
  }
};

chrome.tabs.onUpdated.addListener((tabId, changeInfo, tab) => {
  if (changeInfo.status === "complete" && tab.active && tab.url) {
    console.log(
      `[BG] onUpdated: complete & active for tab ${tabId}, url: ${tab.url}`
    );
    handleTabUpdate(tab.url, tabId);
  }
});
chrome.tabs.onActivated.addListener(async (activeInfo) => {
  chrome.tabs.get(activeInfo.tabId, (tab) => {
    if (tab.url) {
      console.log(`[BG] onActivated: tab ${activeInfo.tabId}, url: ${tab.url}`);
      handleTabUpdate(tab.url, activeInfo.tabId);
    }
  });
});
chrome.runtime.onStartup.addListener(() => {
  chrome.tabs.query({ active: true, currentWindow: true }, (tabs) => {
    if (tabs[0]?.url) {
      console.log(
        `[BG] onStartup: active tab ${tabs[0].id}, url: ${tabs[0].url}`
      );
      handleTabUpdate(tabs[0].url, tabs[0].id);
    }
  });
});
chrome.windows.onFocusChanged.addListener((windowId) => {
  if (windowId !== chrome.windows.WINDOW_ID_NONE) {
    chrome.tabs.query({ active: true, windowId: windowId }, (tabs) => {
      if (tabs[0]?.url) {
        console.log(
          `[BG] onFocusChanged: window ${windowId}, active tab ${tabs[0].id}, url: ${tabs[0].url}`
        );
        handleTabUpdate(tabs[0].url, tabs[0].id);
      }
    });
  }
});

chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {
  console.log("[BG] Received message:", message, "From sender:", sender);
  if (message.action === "requestAnalysisForCurrentTab") {
    const tabToUse = sender.tab || message.tab; // Użyj zakładki z której przyszła wiadomość (popup), lub przekazanej
    const urlToAnalyze = tabToUse?.url || message.url;
    const tabIdForContent = tabToUse?.id;

    if (urlToAnalyze) {
      const domain = getDomainFromUrl(urlToAnalyze);
      if (domain) {
        console.log(
          `[BG] requestAnalysisForCurrentTab for ${domain} (URL: ${urlToAnalyze}). Force content: ${!!message.forceContentRefresh}. Tab for content: ${tabIdForContent}`
        );
        triggerAnalysisForUrl(
          urlToAnalyze,
          !!message.forceContentRefresh,
          tabIdForContent
        );
        sendResponse({ status: "analysis_triggered", lastChecked: Date.now() });
      } else {
        console.warn(
          "[BG] requestAnalysisForCurrentTab: No valid domain for URL:",
          urlToAnalyze
        );
        sendResponse({ error: "No valid domain.", lastChecked: Date.now() });
      }
    } else {
      console.warn(
        "[BG] requestAnalysisForCurrentTab: No URL provided or found in sender."
      );
      sendResponse({ error: "No active tab/URL.", lastChecked: Date.now() });
    }
    return true; // Niezbędne dla asynchronicznej odpowiedzi triggerAnalysisForUrl
  }

  if (message.action === "analyzePageContent") {
    const { url, contentChunks } = message;
    if (!url) {
      console.error("[BG] analyzePageContent: URL missing in message.");
      sendResponse({ success: false, error: "URL missing." });
      return false;
    }
    const domain = getDomainFromUrl(url);
    console.log(
      `[BG] Received ${
        contentChunks?.length || 0
      } content chunks from content script for URL:`,
      url
    );
    performFullAnalysis(url, contentChunks)
      .then((data) => {
        console.log(
          `[BG] Analysis complete (after content chunks received) for ${domain}. Sending update.`
        );
        chrome.runtime
          .sendMessage({ action: "analysisUpdated", domain, data, forUrl: url })
          .catch((e) =>
            console.warn(
              "[BG] Error sending analysisUpdated (analyzePageContent):",
              e.message
            )
          );
        sendResponse({ success: true }); // Odpowiedź do content.ts
      })
      .catch((error) => {
        console.error(
          "[BG] Error in performFullAnalysis (from analyzePageContent):",
          error
        );
        sendResponse({ success: false, error: error.message });
      });
    return true;
  }

  if (message.action === "updateExtensionBadge") {
    if (message.text !== undefined && message.color !== undefined) {
      updateBadge(message.text, message.color);
      sendResponse({ success: true });
    } else {
      sendResponse({ success: false, error: "Missing text/color for badge." });
    }
    return true; // Asynchroniczna odpowiedź nie jest tu potrzebna, ale zostawiam dla spójności
  }
  console.log(
    "[BG] Message action not recognized or not handled:",
    message.action
  );
  return false; // Zwróć false, jeśli nie obsługujesz akcji lub nie wysyłasz asynchronicznej odpowiedzi
});

console.log("[BG] Background script loaded and listeners attached (v1.0.3).");

--------------------
File: C:\Users\mikol\Desktop\IsThisPhishy-addon\src\components\ui\button.tsx
--------------------
import * as React from "react";
import { Slot } from "@radix-ui/react-slot";
import { cva } from "class-variance-authority";

import { cn } from "@/lib/utils";

const buttonVariants = cva(
  "inline-flex items-center justify-center whitespace-nowrap rounded-md text-sm font-medium ring-offset-background transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50",
  {
    variants: {
      variant: {
        default: "bg-primary text-primary-foreground hover:bg-primary/90",
        destructive:
          "bg-destructive text-destructive-foreground hover:bg-destructive/90",
        outline:
          "border border-input bg-background hover:bg-accent hover:text-accent-foreground",
        secondary:
          "bg-secondary text-secondary-foreground hover:bg-secondary/80",
        ghost: "hover:bg-accent hover:text-accent-foreground",
        link: "text-primary underline-offset-4 hover:underline",
      },
      size: {
        default: "h-10 px-4 py-2",
        sm: "h-9 rounded-md px-3",
        lg: "h-11 rounded-md px-8",
        icon: "h-10 w-10",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  }
);

interface ButtonProps extends React.ButtonHTMLAttributes<HTMLButtonElement> {
  variant?:
    | "default"
    | "destructive"
    | "outline"
    | "secondary"
    | "ghost"
    | "link";
  size?: "default" | "sm" | "lg";
  asChild?: boolean;
}

const Button = React.forwardRef<HTMLButtonElement, ButtonProps>(
  ({ className, variant, size, asChild = false, ...props }, ref) => {
    const Comp = asChild ? Slot : "button";
    return (
      <Comp
        className={cn(buttonVariants({ variant, size, className }))}
        ref={ref}
        {...props}
      />
    );
  }
);
Button.displayName = "Button";

export { Button, buttonVariants };

--------------------
File: C:\Users\mikol\Desktop\IsThisPhishy-addon\src\components\ui\progress.tsx
--------------------
"use client";

import * as React from "react";
import * as ProgressPrimitive from "@radix-ui/react-progress";

import { cn } from "@/lib/utils";

const Progress = React.forwardRef<
  React.ElementRef<typeof ProgressPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof ProgressPrimitive.Root>
>(({ className, value, ...props }, ref) => (
  <ProgressPrimitive.Root
    ref={ref}
    className="relative h-2 w-full overflow-hidden rounded-full bg-secondary shadow-lg "
    {...props}
  >
    <ProgressPrimitive.Indicator
      className={cn(`h-full w-full flex-1 transition-all`, className)}
      style={{ transform: `translateX(-${100 - (value ?? 0)}%)` }}
    />
  </ProgressPrimitive.Root>
));
Progress.displayName = ProgressPrimitive.Root.displayName;

export { Progress };

--------------------
File: C:\Users\mikol\Desktop\IsThisPhishy-addon\src\components\ui\switch.tsx
--------------------
"use client"

import * as React from "react"
import * as SwitchPrimitives from "@radix-ui/react-switch"

import { cn } from "@/lib/utils"

const Switch = React.forwardRef<
  React.ElementRef<typeof SwitchPrimitives.Root>,
  React.ComponentPropsWithoutRef<typeof SwitchPrimitives.Root>
>(({ className, ...props }, ref) => (
  <SwitchPrimitives.Root
    className={cn(
      "peer inline-flex h-6 w-11 shrink-0 cursor-pointer items-center rounded-full border-2 border-transparent transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 focus-visible:ring-offset-background disabled:cursor-not-allowed disabled:opacity-50 data-[state=checked]:bg-primary data-[state=unchecked]:bg-input",
      className
    )}
    {...props}
    ref={ref}
  >
    <SwitchPrimitives.Thumb
      className={cn(
        "pointer-events-none block h-5 w-5 rounded-full bg-background shadow-lg ring-0 transition-transform data-[state=checked]:translate-x-5 data-[state=unchecked]:translate-x-0"
      )}
    />
  </SwitchPrimitives.Root>
))
Switch.displayName = SwitchPrimitives.Root.displayName

export { Switch }

--------------------
File: C:\Users\mikol\Desktop\IsThisPhishy-addon\src\components\ui\tooltip.tsx
--------------------
"use client";

import * as React from "react";
import * as TooltipPrimitive from "@radix-ui/react-tooltip";

import { cn } from "@/lib/utils";

const TooltipProvider = TooltipPrimitive.Provider;

const Tooltip = TooltipPrimitive.Root;

const TooltipTrigger = TooltipPrimitive.Trigger;

const TooltipContent = React.forwardRef<
  React.ElementRef<typeof TooltipPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof TooltipPrimitive.Content>
>(({ className, sideOffset = 4, ...props }, ref) => (
  <TooltipPrimitive.Content
    ref={ref}
    sideOffset={sideOffset}
    className={cn(
      "z-50 overflow-hidden rounded-md border bg-popover px-3 py-1.5 text-sm text-popover-foreground shadow-md animate-in fade-in-0 zoom-in-95 data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=closed]:zoom-out-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
      className,
    )}
    {...props}
  />
));
TooltipContent.displayName = TooltipPrimitive.Content.displayName;

export { Tooltip, TooltipTrigger, TooltipContent, TooltipProvider };

--------------------
File: C:\Users\mikol\Desktop\IsThisPhishy-addon\src\content\content.ts
--------------------
import "../styles/globals.css";

const MAX_TEXT_CHUNKS = 5;
const MIN_CHUNK_LENGTH = 100;
const TARGET_CHUNK_LENGTH = 300;

function isVisible(element: HTMLElement | null): boolean {
  if (!(element instanceof HTMLElement)) return false;
  const style = window.getComputedStyle(element);
  const rect = element.getBoundingClientRect();
  return (
    style.display !== "none" &&
    style.visibility !== "hidden" &&
    style.opacity !== "0" &&
    element.offsetParent !== null &&
    rect.width > 0 &&
    rect.height > 0 &&
    rect.top < window.innerHeight &&
    rect.bottom > 0 &&
    rect.left < window.innerWidth &&
    rect.right > 0
  );
}

function extractVisibleTextChunks(): string[] {
  const chunks: string[] = [];
  let currentChunk = "";
  const BANNED_TAGS = [
    "script",
    "style",
    "noscript",
    "iframe",
    "canvas",
    "svg",
    "path",
    "head",
    "meta",
    "link",
  ];
  // const LOW_PRIORITY_TAGS = ['button', 'a', 'nav', 'footer', 'header', 'figcaption', 'aside', 'details', 'summary']; // Zakomentowane, bo nieużywane

  function traverseNodes(node: Node, depth = 0) {
    if (chunks.length >= MAX_TEXT_CHUNKS * 2 || depth > 20) return;

    if (node.nodeType === Node.TEXT_NODE) {
      const parentElement = node.parentNode as HTMLElement;
      if (parentElement && isVisible(parentElement)) {
        const text = node.nodeValue?.replace(/\s+/g, " ").trim();
        if (text && text.length > 5) {
          const tagName = parentElement.tagName.toLowerCase();
          if (BANNED_TAGS.includes(tagName)) return;

          currentChunk += text + " ";
          if (currentChunk.length >= TARGET_CHUNK_LENGTH) {
            chunks.push(currentChunk.trim());
            currentChunk = "";
            if (chunks.length >= MAX_TEXT_CHUNKS * 2) return;
          }
        }
      }
    } else if (node.nodeType === Node.ELEMENT_NODE) {
      const element = node as HTMLElement;
      const tagName = element.tagName.toLowerCase();
      if (BANNED_TAGS.includes(tagName)) return;

      if (isVisible(element)) {
        for (let i = 0; i < node.childNodes.length; i++) {
          traverseNodes(node.childNodes[i], depth + 1);
          if (chunks.length >= MAX_TEXT_CHUNKS * 2) return;
        }
      }
    }
  }

  if (document.body) traverseNodes(document.body);

  if (currentChunk.trim().length >= MIN_CHUNK_LENGTH)
    chunks.push(currentChunk.trim());

  // console.log("[ContentScript] Raw chunks extracted:", chunks.length); // Możesz odkomentować do debugowania
  const filteredChunks = chunks
    .filter((chunk) => chunk.length >= MIN_CHUNK_LENGTH)
    .map((chunk) => chunk.substring(0, TARGET_CHUNK_LENGTH * 2))
    .sort((a, b) => b.length - a.length)
    .slice(0, MAX_TEXT_CHUNKS);
  // console.log("[ContentScript] Filtered chunks for analysis:", filteredChunks.length); // Możesz odkomentować
  return filteredChunks;
}

function sendTextToBackground() {
  const textChunks = extractVisibleTextChunks();
  if (
    document.body.innerText.trim().length < MIN_CHUNK_LENGTH &&
    textChunks.length === 0
  ) {
    console.log(
      "[ContentScript] Page content too short or no significant text chunks found."
    );
    chrome.runtime.sendMessage({
      action: "analyzePageContent",
      url: window.location.href,
      contentChunks: [],
    });
    return;
  }

  console.log(
    `[ContentScript] Sending ${textChunks.length} text chunks to background.`
  );
  chrome.runtime.sendMessage(
    {
      action: "analyzePageContent",
      url: window.location.href,
      contentChunks: textChunks,
    },
    (response) => {
      if (chrome.runtime.lastError)
        console.warn(
          "[CS] Error sending content:",
          chrome.runtime.lastError.message
        );
      else if (response && !response.success)
        console.warn("[CS] BG failed to process content:", response.error);
    }
  );
}

chrome.runtime.onMessage.addListener((request, sender, sendResponse) => {
  if (request.action === "getTextContentFromPage") {
    console.log("[ContentScript] Received getTextContentFromPage request.");
    requestAnimationFrame(() => {
      setTimeout(() => {
        try {
          sendTextToBackground();
          sendResponse({ status: "processing_initiated_by_content" });
        } catch (e) {
          console.error(
            "[ContentScript] Error in sendTextToBackground/sendResponse:",
            e
          );
          sendResponse({
            status: "error",
            error: e instanceof Error ? e.message : String(e),
          });
        }
      }, 50);
    });
    return true;
  }
  return false;
});

console.log("[ContentScript] IsThisPhishy content script v1.0.3 loaded.");

--------------------
File: C:\Users\mikol\Desktop\IsThisPhishy-addon\src\lib\utils.ts
--------------------
import type { ClassValue } from "clsx";
import { clsx } from "clsx";
import { twMerge } from "tailwind-merge";

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs));
}

--------------------
File: C:\Users\mikol\Desktop\IsThisPhishy-addon\src\popup\index.html
--------------------
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="icon" type="image/png" href="/icon.png" />
    <title>IsThisFishy Extension</title>
    <link rel="stylesheet" href="style.css" />
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="./popup.tsx"></script>
  </body>
</html>

--------------------
File: C:\Users\mikol\Desktop\IsThisPhishy-addon\src\popup\popup-content.tsx
--------------------
// src/popup/popup-content.tsx
"use client";
import React from "react";
import { RefreshCw, Loader2, Info } from "lucide-react";
import { Button } from "@/components/ui/button";
import { useAnalysisData } from "./hooks/useAnalysisData";
import { Header, Footer } from "./components/Header";
import { LoadingIndicator } from "./components/LoadingIndicator";
import { ErrorDisplay } from "./components/ErrorDisplay";
import { ScoreDisplay } from "./components/ScoreDisplay";
import { ScoreExplanationsList } from "./components/ScoreExplanations";

export const PopupContent = () => {
  const {
    storedData,
    currentUrl,
    currentDomain,
    isLoading,
    isRefreshing,
    trustScore,
    scoreExplanations,
    fetchData,
  } = useAnalysisData();

  const handleRefresh = () => {
    console.log("[Popup] Manual refresh triggered.");
    fetchData(true, true);
  };

  let content;
  const showInitialLoader =
    isLoading && !isRefreshing && !storedData?.analysis && !storedData?.error;
  const showErrorDisplay =
    storedData?.error &&
    (!trustScore || scoreExplanations.length === 0) &&
    !isRefreshing &&
    !isLoading;

  if (showInitialLoader) {
    content = <LoadingIndicator message="Inicjalizacja analizy..." />;
  } else if (showErrorDisplay) {
    content = (
      <ErrorDisplay
        error={storedData!.error!}
        onRetry={handleRefresh}
        isRetrying={isRefreshing}
      />
    );
  } else if (
    trustScore !== null ||
    scoreExplanations.length > 0 ||
    isRefreshing ||
    isLoading
  ) {
    content = (
      <>
        <ScoreDisplay
          score={trustScore}
          isLoading={isLoading || isRefreshing}
          errorOccurred={!!storedData?.error && !isLoading && !isRefreshing} // Pokaż błąd tylko jeśli nie ładujemy
          currentDomain={currentDomain}
          currentUrl={currentUrl}
        />
        <ScoreExplanationsList
          explanations={scoreExplanations}
          isLoading={isLoading || isRefreshing} // Przekaż oba stany
          errorOccurred={!!storedData?.error && !isLoading && !isRefreshing}
        />
        <Button
          onClick={handleRefresh}
          variant="secondary"
          size="sm"
          className="w-full mt-auto"
          disabled={isRefreshing || isLoading}
        >
          {isRefreshing || (isLoading && !trustScore && !storedData?.error) ? (
            <Loader2 className="mr-2 h-4 w-4 animate-spin" />
          ) : (
            <RefreshCw className="mr-2 h-4 w-4" />
          )}
          {isRefreshing ? "Odświeżanie..." : "Odśwież (z analizą treści)"}
        </Button>
      </>
    );
  } else {
    content = (
      <div className="flex flex-col items-center justify-center h-full py-4">
        <Info className="mx-auto mb-2 h-10 w-10 text-blue-500" />
        <p className="mb-4 text-sm text-gray-600 text-center px-2">
          {!currentDomain
            ? "Otwórz stronę http/https, aby rozpocząć analizę."
            : "Kliknij, aby przeanalizować tę stronę."}
        </p>
        <Button
          onClick={handleRefresh}
          variant="default"
          size="sm"
          disabled={isRefreshing || isLoading || !currentDomain}
        >
          {isLoading || isRefreshing ? (
            <Loader2 className="mr-2 h-4 w-4 animate-spin" />
          ) : (
            <RefreshCw className="mr-2 h-4 w-4" />
          )}
          Analizuj {currentDomain || ""}
        </Button>
      </div>
    );
  }

  return (
    <div className="w-96 rounded-md bg-white p-4 shadow-xl flex flex-col max-h-[580px] min-h-[450px]">
      <Header />
      <div className="flex-grow overflow-hidden flex flex-col">{content}</div>
      <Footer />
    </div>
  );
};

--------------------
File: C:\Users\mikol\Desktop\IsThisPhishy-addon\src\popup\popup.tsx
--------------------
import React from "react";
import ReactDOM from "react-dom/client";

import "../styles/globals.css";

import { PopupContent } from "./popup-content";

ReactDOM.createRoot(document.getElementById("root") as HTMLElement).render(
  <React.StrictMode>
    <PopupContent></PopupContent>
  </React.StrictMode>,
);

--------------------
File: C:\Users\mikol\Desktop\IsThisPhishy-addon\src\popup\components\ErrorDisplay.tsx
--------------------
// src/popup/components/ErrorDisplay.tsx
import React from "react";
import { FileWarning, RefreshCw, Loader2 } from "lucide-react";
import { Button } from "@/components/ui/button";

interface ErrorDisplayProps {
  error: string;
  onRetry: () => void;
  isRetrying: boolean;
}

export const ErrorDisplay: React.FC<ErrorDisplayProps> = ({
  error,
  onRetry,
  isRetrying,
}) => (
  <div className="flex flex-col items-center justify-center h-full py-4">
    <FileWarning className="mb-2 h-10 w-10 text-red-500" />
    <p className="mb-1 text-base font-semibold text-gray-800">Błąd Analizy</p>
    <p className="mb-4 text-xs text-gray-600 px-2 text-center">{error}</p>
    <Button onClick={onRetry} variant="outline" size="sm" disabled={isRetrying}>
      {isRetrying ? (
        <Loader2 className="mr-2 h-4 w-4 animate-spin" />
      ) : (
        <RefreshCw className="mr-2 h-4 w-4" />
      )}
      Spróbuj Ponownie
    </Button>
  </div>
);

--------------------
File: C:\Users\mikol\Desktop\IsThisPhishy-addon\src\popup\components\Header.tsx
--------------------
// src/popup/components/Header.tsx
import React from "react";
import { ExternalLink } from "lucide-react";

export const Header: React.FC = () => (
  <div className="mb-3 flex items-center justify-between">
    <div className="flex items-center">
      <img src="/icon.png" width={28} height={28} alt="Logo" className="mr-2" />
      <h1 className="text-lg font-bold text-gray-800">IsThisPhishy?</h1>
    </div>
  </div>
);

export const Footer: React.FC = () => (
  <div className="mt-auto pt-2 border-t border-gray-200 text-center">
    <a
      href="https://github.com/MikiKru/IsThisPhishy-licencjat"
      target="_blank"
      rel="noopener noreferrer"
      className="text-xs text-blue-600 hover:underline hover:text-blue-800"
    >
      O projekcie <ExternalLink className="ml-1 h-3 w-3 inline-block" />
    </a>
  </div>
);

--------------------
File: C:\Users\mikol\Desktop\IsThisPhishy-addon\src\popup\components\InfoRow.tsx
--------------------
// src/popup/components/InfoRow.tsx
import React from "react";
import { ChevronDown, ChevronUp } from "lucide-react";
import {
  Tooltip,
  TooltipContent,
  TooltipProvider,
  TooltipTrigger,
} from "@/components/ui/tooltip";
import { ScoreExplanation } from "../services/scoreCalculator"; // Załóżmy, że typ jest tam

interface InfoRowProps extends ScoreExplanation {
  isExpanded?: boolean;
  onToggle?: () => void;
}

export const InfoRow: React.FC<InfoRowProps> = ({
  icon: Icon,
  label,
  valueText,
  impact,
  details,
  longDesc,
  scoreEffect,
  isExpanded,
  onToggle,
}) => {
  const getIconColor = () => {
    switch (impact) {
      case "positive":
        return "text-green-500";
      case "negative":
        return "text-red-500";
      case "info":
        return "text-blue-500";
      default:
        return "text-gray-500";
    }
  };

  return (
    <TooltipProvider delayDuration={300}>
      <div className="mb-1 border-b border-gray-200 last:border-b-0 py-2">
        <Tooltip>
          <TooltipTrigger asChild>
            <div
              className="flex items-center justify-between text-sm cursor-pointer"
              onClick={longDesc && onToggle ? onToggle : undefined}
              onKeyDown={
                longDesc && onToggle
                  ? (e) => (e.key === "Enter" || e.key === " ") && onToggle()
                  : undefined
              }
              role={longDesc ? "button" : undefined}
              tabIndex={longDesc ? 0 : undefined}
              aria-expanded={longDesc ? isExpanded : undefined}
              aria-controls={
                longDesc
                  ? `desc-${label.replace(/\s+/g, "-").toLowerCase()}`
                  : undefined
              }
            >
              <div className="flex items-center min-w-0">
                {" "}
                {/* min-w-0 dla truncate */}
                <Icon className={`mr-2 h-5 w-5 shrink-0 ${getIconColor()}`} />
                <span className="font-medium truncate" title={label}>
                  {label}:
                </span>{" "}
                {/* truncate */}
              </div>
              <div className="flex items-center ml-2 shrink-0">
                {" "}
                {/* shrink-0 zapobiega rozpychaniu */}
                <span className="text-right break-words">{valueText}</span>{" "}
                {/* break-words dla długich wartości */}
                {longDesc &&
                  (isExpanded ? (
                    <ChevronUp className="ml-1 h-4 w-4 text-gray-500" />
                  ) : (
                    <ChevronDown className="ml-1 h-4 w-4 text-gray-500" />
                  ))}
              </div>
            </div>
          </TooltipTrigger>
          <TooltipContent
            side="top"
            className="max-w-xs text-center bg-gray-800 text-white rounded-md p-2 shadow-lg"
          >
            <p>{details}</p>
            {scoreEffect && (
              <p className="text-xs italic mt-1">({scoreEffect})</p>
            )}
          </TooltipContent>
        </Tooltip>
        {longDesc && isExpanded && (
          <div
            id={`desc-${label.replace(/\s+/g, "-").toLowerCase()}`}
            className="mt-2 pl-7 text-xs text-gray-600 bg-gray-50 p-2 rounded prose prose-sm max-w-full overflow-x-auto"
          >
            {typeof longDesc === "string" ? <p>{longDesc}</p> : longDesc}
          </div>
        )}
      </div>
    </TooltipProvider>
  );
};

--------------------
File: C:\Users\mikol\Desktop\IsThisPhishy-addon\src\popup\components\LoadingIndicator.tsx
--------------------
// src/popup/components/LoadingIndicator.tsx
import React from "react";
import { Loader2 } from "lucide-react";

interface LoadingIndicatorProps {
  message?: string;
}

export const LoadingIndicator: React.FC<LoadingIndicatorProps> = ({
  message = "Ładowanie danych...",
}) => (
  <div className="flex flex-col items-center justify-center h-full py-8">
    <Loader2 className="mb-4 h-10 w-10 animate-spin text-blue-600" />
    <p className="text-sm text-gray-600">{message}</p>
  </div>
);

--------------------
File: C:\Users\mikol\Desktop\IsThisPhishy-addon\src\popup\components\ScoreDisplay.tsx
--------------------
// src/popup/components/ScoreDisplay.tsx
import React from "react";
import { Loader2 } from "lucide-react";

interface ScoreDisplayProps {
  score: number | null;
  isLoading: boolean; // Czy główny wynik jest ładowany
  errorOccurred?: boolean;
  currentDomain: string;
  currentUrl: string;
}

export const ScoreDisplay: React.FC<ScoreDisplayProps> = ({
  score,
  isLoading,
  errorOccurred,
  currentDomain,
  currentUrl,
}) => {
  const getScoreColorClasses = (
    s: number | null
  ): { bg: string; text: string; ring: string } => {
    if (s === null)
      return {
        bg: "bg-gray-400",
        text: "text-gray-700",
        ring: "ring-gray-400",
      };
    if (s < 40)
      return { bg: "bg-red-500", text: "text-white", ring: "ring-red-500" };
    if (s < 70)
      return {
        bg: "bg-yellow-500",
        text: "text-black",
        ring: "ring-yellow-500",
      };
    return { bg: "bg-green-500", text: "text-white", ring: "ring-green-500" };
  };

  const getScoreTextDescription = (
    s: number | null,
    loading: boolean,
    error: boolean | undefined
  ): string => {
    if (loading && s === null && !error) return "Analizowanie...";
    if (error && s === null) return "Błąd Oceny";
    if (s === null && !loading) return "Brak Oceny";
    if (s === null) return "Analizowanie..."; // Fallback
    if (s < 40) return "Wysokie Ryzyko";
    if (s < 70) return "Podwyższone Ryzyko";
    return "Niskie Ryzyko";
  };

  const colorClasses = getScoreColorClasses(score);
  const scoreText = getScoreTextDescription(score, isLoading, errorOccurred);

  return (
    <div className="mb-4 text-center">
      <div
        className={`mx-auto mb-3 h-20 w-20 rounded-full ring-4 ${colorClasses.ring} ${colorClasses.bg} flex items-center justify-center`}
      >
        <span className={`text-3xl font-bold ${colorClasses.text}`}>
          {isLoading && score === null && !errorOccurred ? (
            <Loader2 className="h-8 w-8 animate-spin" />
          ) : (
            score ?? "?"
          )}
        </span>
      </div>
      <p
        className={`text-lg font-semibold ${colorClasses.text
          .replace("text-white", "text-gray-800")
          .replace("text-black", "text-gray-800")
          .replace("text-gray-700", "text-gray-600")}`}
      >
        {" "}
        {/* Użyj ciemniejszego tekstu dla opisu */}
        {scoreText}
      </p>
      <p
        className="text-xs text-gray-500 mt-1 truncate px-2"
        title={currentUrl}
      >
        Analiza dla:{" "}
        <span className="font-medium">{currentDomain || "Bieżąca strona"}</span>
      </p>
    </div>
  );
};

--------------------
File: C:\Users\mikol\Desktop\IsThisPhishy-addon\src\popup\components\ScoreExplanations.tsx
--------------------
// src/popup/components/ScoreExplanations.tsx
import React, { useState } from "react";
import { Loader2 } from "lucide-react";
import { InfoRow } from "./InfoRow"; // Zakładając, że jest w tym samym folderze
import { ScoreExplanation } from "../services/scoreCalculator";

interface ScoreExplanationsProps {
  explanations: ScoreExplanation[];
  isLoading: boolean; // Czy wskaźniki są ładowane
  errorOccurred?: boolean;
}

export const ScoreExplanationsList: React.FC<ScoreExplanationsProps> = ({
  explanations,
  isLoading,
  errorOccurred,
}) => {
  const [expandedRow, setExpandedRow] = useState<string | null>(null);
  const toggleRowExpansion = (id: string) =>
    setExpandedRow(expandedRow === id ? null : id);

  if (isLoading && explanations.length === 0 && !errorOccurred) {
    return (
      <div className="text-center py-4">
        <Loader2 className="mx-auto h-6 w-6 animate-spin text-gray-400" />
        <p className="text-xs text-gray-500 mt-1">Ładowanie wskaźników...</p>
      </div>
    );
  }

  if (explanations.length === 0 && !isLoading && !errorOccurred) {
    return (
      <p className="text-xs text-gray-500 text-center py-4">
        Brak szczegółowych wskaźników do wyświetlenia.
      </p>
    );
  }
  if (explanations.length === 0 && errorOccurred) {
    return null; // Nie pokazuj nic, jeśli jest globalny błąd
  }

  return (
    <div className="mb-3 flex-grow overflow-y-auto pr-1 custom-scrollbar">
      {" "}
      {/* custom-scrollbar jeśli masz definicję */}
      <h3 className="text-sm font-semibold text-gray-700 mb-2 sticky top-0 bg-white py-1 z-10 border-b">
        Kluczowe Wskaźniki:
      </h3>
      {explanations.map((exp) => (
        <InfoRow
          key={exp.id}
          {...exp}
          isExpanded={expandedRow === exp.id}
          onToggle={() => toggleRowExpansion(exp.id)}
        />
      ))}
    </div>
  );
};

--------------------
File: C:\Users\mikol\Desktop\IsThisPhishy-addon\src\popup\hooks\useAnalysisData.ts
--------------------
// src/popup/hooks/useAnalysisData.ts
import { useState, useEffect, useCallback } from "react";
import { StoredDomainData } from "@/types/domainAnalysis";
import {
  calculateTrustScore,
  ScoreExplanation,
} from "../services/scoreCalculator";
import { getDomainFromUrl as getDomainFromUrlHelper } from "../utils/helpers";

export function useAnalysisData() {
  const [storedData, setStoredData] = useState<StoredDomainData | null>(null);
  const [currentUrl, setCurrentUrl] = useState<string>("");
  const [currentDomain, setCurrentDomain] = useState<string>("");
  const [isLoading, setIsLoading] = useState(true);
  const [isRefreshing, setIsRefreshing] = useState(false);
  const [trustScore, setTrustScore] = useState<number | null>(null);
  const [scoreExplanations, setScoreExplanations] = useState<
    ScoreExplanation[]
  >([]);

  const updateBadge = useCallback(
    (score: number | null, error?: string | null, loading?: boolean): void => {
      let text = "",
        color = "#777777";
      if (loading) {
        text = "...";
        color = "#F59E0B";
      } else if (error) {
        text = "!";
        color = "#EF4444";
      } else if (score !== null) {
        text = score.toString();
        if (score < 40) color = "#EF4444";
        else if (score < 70) color = "#F59E0B";
        else color = "#10B981";
      }
      try {
        chrome.runtime.sendMessage(
          { action: "updateExtensionBadge", text, color },
          (response) => {
            if (chrome.runtime.lastError) {
              console.warn(
                "[Hook] Badge update sendMessage error:",
                chrome.runtime.lastError.message
              );
            } else if (response && !response.success) {
              console.warn("[Hook] Background failed to update badge.");
            }
          }
        );
      } catch (e) {
        console.warn("[Hook] Error trying to send badge update message:", e);
      }
    },
    []
  );

  const processData = useCallback(
    (data: StoredDomainData | null, urlForAnalysis: string) => {
      console.log(
        "[Hook] processData called with data for URL:",
        urlForAnalysis,
        data
      );
      setStoredData(data);
      if (data?.error && (!data.analysis || !data.urlTextAnalysis)) {
        console.warn("[Hook] Error in received data:", data.error);
        setTrustScore(null);
        setScoreExplanations([]);
        updateBadge(null, data.error, false);
      } else if (data?.analysis) {
        const { score, explanations } = calculateTrustScore(
          data,
          urlForAnalysis
        );
        setTrustScore(score);
        setScoreExplanations(explanations);
        updateBadge(score, data.error, false); // Przekaż błąd, jeśli istnieje, nawet z częściowymi danymi
      } else {
        setTrustScore(null);
        setScoreExplanations([]);
        updateBadge(null, null, isLoading || isRefreshing);
      }
    },
    [updateBadge, isLoading, isRefreshing]
  );

  const fetchData = useCallback(
    (forceRefresh = false, forceContentFetch = false) => {
      if (!currentUrl) {
        console.warn("[Hook] fetchData: No currentUrl to analyze.");
        setIsLoading(false);
        setIsRefreshing(false);
        processData(
          { error: "Brak aktywnego URL.", lastChecked: Date.now() },
          ""
        );
        return;
      }

      console.log(
        `[Hook] fetchData triggered. forceRefresh: ${forceRefresh}, forceContent: ${forceContentFetch}, URL: ${currentUrl}`
      );

      if (forceRefresh) setIsRefreshing(true);
      else setIsLoading(true);
      updateBadge(null, null, true);

      chrome.runtime.sendMessage(
        {
          action: "requestAnalysisForCurrentTab",
          forceContentRefresh: forceContentFetch || forceRefresh,
          forDomain: currentDomain,
          url: currentUrl,
        },
        (response) => {
          console.log(
            "[Hook] fetchData response from background:",
            response,
            "For URL:",
            currentUrl
          );
          let needsReset = true; // Czy resetować flagi ładowania

          if (chrome.runtime.lastError) {
            console.error(
              "[Hook] fetchData sendMessage error:",
              chrome.runtime.lastError.message
            );
            processData(
              { error: "Błąd komunikacji z tłem.", lastChecked: Date.now() },
              currentUrl
            );
          } else if (
            response?.status?.includes("triggered") ||
            response?.status?.includes("processing")
          ) {
            console.log(
              "[Hook] Background is processing, will wait for 'analysisUpdated'."
            );
            needsReset = false; // Nie resetuj, czekamy na inną wiadomość
          } else if (response?.error) {
            processData(response as StoredDomainData, currentUrl);
          } else if (response) {
            processData(response as StoredDomainData, currentUrl);
          } else {
            processData(
              {
                error: "Nieoczekiwana odpowiedź od tła.",
                lastChecked: Date.now(),
              },
              currentUrl
            );
          }

          if (needsReset) {
            if (forceRefresh) setIsRefreshing(false);
            else setIsLoading(false);
          }
        }
      );
    },
    [currentUrl, currentDomain, processData, updateBadge]
  );

  useEffect(() => {
    console.log(
      "[Hook] Initializing: attaching listeners, getting active tab."
    );
    setIsLoading(true);
    updateBadge(null, null, true);

    chrome.tabs.query({ active: true, currentWindow: true }, (tabs) => {
      const activeTab = tabs[0];
      if (activeTab?.url && activeTab.url.startsWith("http")) {
        const newUrl = activeTab.url;
        const newDomain = getDomainFromUrlHelper(newUrl);
        console.log(
          `[Hook] Initial active tab: ${newUrl} (Domain: ${newDomain})`
        );
        setCurrentUrl(newUrl);
        setCurrentDomain(newDomain);
      } else {
        console.warn("[Hook] No valid active tab URL for initialization.");
        setCurrentUrl("");
        setCurrentDomain("");
        processData(
          {
            error: "Brak aktywnej strony http/https.",
            lastChecked: Date.now(),
          },
          ""
        );
        setIsLoading(false);
      }
    });
  }, []); // Uruchom tylko raz przy montażu hooka

  useEffect(() => {
    if (currentUrl && currentDomain && isLoading) {
      // Dopiero gdy URL jest ustawiony i jesteśmy w stanie isLoading
      console.log(
        `[Hook] URL/Domain set (${currentUrl}). Checking cache or fetching.`
      );
      chrome.storage.local.get(currentDomain, (result) => {
        const cachedData: StoredDomainData | undefined = result[currentDomain];
        const fiveMinutes = 5 * 60 * 1000;
        if (
          cachedData?.analysis && // Upewnij się, że kluczowe dane są w cache
          Date.now() - cachedData.lastChecked < fiveMinutes &&
          !cachedData.error
        ) {
          console.log(
            "[Hook] Using cached data for",
            currentDomain,
            cachedData
          );
          processData(cachedData, currentUrl);
          setIsLoading(false);
        } else {
          console.log(
            "[Hook] Cache miss or invalid for",
            currentDomain,
            ". Fetching fresh data with content."
          );
          fetchData(false, true);
        }
      });
    } else if (!currentUrl && isLoading) {
      // Jeśli URL się nie ustawił, a nadal ładujemy
      setIsLoading(false); // Zakończ ładowanie, bo nie ma co analizować
      processData(
        {
          error: "Nie można ustalić adresu URL aktywnej karty.",
          lastChecked: Date.now(),
        },
        ""
      );
    }
  }, [currentUrl, currentDomain, isLoading, fetchData, processData]);

  useEffect(() => {
    console.log("[Hook] Attaching message listener.");
    const messageListener = (message: {
      action: string;
      domain?: string;
      data?: StoredDomainData;
    }) => {
      console.log("[Hook] Message received from background:", message);
      if (
        message.action === "analysisUpdated" &&
        message.data &&
        message.domain
      ) {
        if (message.domain === currentDomain) {
          console.log(
            "[Hook] 'analysisUpdated' for current domain:",
            message.domain,
            "Applying data."
          );
          processData(message.data, currentUrl);
          setIsLoading(false);
          setIsRefreshing(false);
        } else {
          console.log(
            `[Hook] 'analysisUpdated' for domain ${message.domain}, but current is ${currentDomain}. Ignoring.`
          );
        }
      }
    };
    chrome.runtime.onMessage.addListener(messageListener);
    return () => {
      console.log("[Hook] Cleaning up message listener.");
      chrome.runtime.onMessage.removeListener(messageListener);
    };
  }, [currentDomain, currentUrl, processData]);

  return {
    storedData,
    currentUrl,
    currentDomain,
    isLoading,
    isRefreshing,
    trustScore,
    scoreExplanations,
    fetchData,
  };
}

--------------------
File: C:\Users\mikol\Desktop\IsThisPhishy-addon\src\popup\services\scoreCalculator.ts
--------------------
// src/popup/services/scoreCalculator.ts
import {
  StoredDomainData,
  PageContentAiAnalysis,
} from "@/types/domainAnalysis";
import { formatDomainAge } from "../utils/helpers";
import {
  ShieldQuestion,
  CalendarDays,
  Lock,
  ShieldAlert,
  ShieldCheck,
  Network,
  MessageSquareQuote,
} from "lucide-react";

export type ExplanationImpact = "positive" | "negative" | "neutral" | "info";
export interface ScoreExplanation {
  id: string;
  icon: React.ElementType;
  label: string;
  valueText: string | React.ReactNode;
  impact: ExplanationImpact;
  details: string;
  longDesc?: string | React.ReactNode;
  scoreEffect?: string;
}

const PTS = {
  age: { y: -15, vy: -25, m: 10, vm: 15, unknown: -5 },
  ssl: { v: 10, e: -20, p: -20, h: -25, es: -5, unknown: -10 },
  bl: { l: -35, c: 5 },
  ip: -20,
  urlAi: { ph: -30, pm: -15, lh: 10, ll: 0, error: -5 },
  cAi: { ah: -25, ap: -15, ml: 5, error: -5, noContent: 0 },
};

export function calculateTrustScore(
  fullData: StoredDomainData | null | undefined,
  currentUrl: string
): { score: number | null; explanations: ScoreExplanation[] } {
  if (!fullData?.analysis) {
    console.warn(
      "[ScoreCalc] No analysis data provided for score calculation."
    );
    return { score: null, explanations: [] };
  }

  const analysisData = fullData.analysis;
  const urlAiAnalysis = fullData.urlTextAnalysis;
  const contentAiAnalyses = fullData.pageContentAnalyses;

  let score = 50;
  const explanations: ScoreExplanation[] = [];
  const MAX = 100,
    MIN = 0;

  console.log("[ScoreCalc] Starting calculation. Initial score:", score);

  const ageD = analysisData.domain_actual_age_days;
  let ageI: ExplanationImpact = "neutral",
    ageSE = "0 pkt";
  if (ageD !== null && typeof ageD !== "undefined") {
    if (ageD < 30) {
      score += PTS.age.vy;
      ageI = "negative";
      ageSE = `${PTS.age.vy} pkt`;
    } else if (ageD < 180) {
      score += PTS.age.y;
      ageI = "negative";
      ageSE = `${PTS.age.y} pkt`;
    } else if (ageD >= 730) {
      score += PTS.age.vm;
      ageI = "positive";
      ageSE = `+${PTS.age.vm} pkt`;
    } else if (ageD >= 365) {
      score += PTS.age.m;
      ageI = "positive";
      ageSE = `+${PTS.age.m} pkt`;
    }
  } else {
    score += PTS.age.unknown;
    ageI = "info";
    ageSE = `${PTS.age.unknown} pkt (brak danych)`;
  }
  explanations.push({
    id: "age",
    icon: CalendarDays,
    label: "Wiek domeny",
    valueText: formatDomainAge(ageD),
    impact: ageI,
    scoreEffect: ageSE,
    details: "Starsze domeny są generalnie bardziej wiarygodne.",
    longDesc:
      "Nowo zarejestrowane domeny są często wykorzystywane w kampaniach phishingowych i innych oszustwach, ponieważ są tanie i łatwe do uzyskania. Domeny z dłuższą historią, które nie były zgłaszane jako złośliwe, budują pewien poziom zaufania.",
  });

  let sslI: ExplanationImpact = "negative",
    sslDet = "Strona nie używa szyfrowania HTTPS.",
    sslVT: React.ReactNode = "Brak (HTTP)";
  let tempSslSE = PTS.ssl.h;
  if (analysisData.parsed_url_scheme === "https") {
    tempSslSE = 0;
    if (analysisData.ssl_info && analysisData.ssl_info.not_after) {
      const expD = new Date(analysisData.ssl_info.not_after);
      const now = new Date();
      const dToExp = (expD.getTime() - now.getTime()) / (1000 * 3600 * 24);
      if (dToExp > 0) {
        tempSslSE = PTS.ssl.v;
        sslI = "positive";
        sslVT = "Ważny";
        sslDet = `Połączenie szyfrowane. Certyfikat ważny do: ${expD.toLocaleDateString()}.`;
        if (dToExp < 30) {
          tempSslSE += PTS.ssl.es;
          sslVT = (
            <span className="text-yellow-600 font-semibold">
              Wygasa wkrótce!
            </span>
          );
          sslDet += " Certyfikat wygasa za mniej niż 30 dni.";
        }
      } else {
        tempSslSE = PTS.ssl.e;
        sslI = "negative";
        sslVT = "Wygasł";
        sslDet = `Certyfikat SSL wygasł: ${expD.toLocaleDateString()}.`;
      }
    } else {
      tempSslSE = PTS.ssl.p;
      sslI = "negative";
      sslVT = "Problem (HTTPS)";
      sslDet =
        "Strona używa HTTPS, ale wystąpił problem z weryfikacją certyfikatu (np. jest on niekompletny, niepasujący do domeny, lub od niezaufanego wystawcy).";
    }
  } else if (
    analysisData.ssl_info === null &&
    analysisData.parsed_url_scheme !== "https"
  ) {
    sslI = "negative";
    sslVT = "Brak (HTTP)";
    sslDet = "Strona nie używa szyfrowania HTTPS (HTTP).";
  } else {
    tempSslSE = PTS.ssl.unknown;
    sslI = "info";
    sslVT = "N/A (SSL)";
    sslDet = "Nie udało się jednoznacznie zweryfikować statusu SSL.";
  }
  score += tempSslSE;
  const sslSETxt = `${tempSslSE > 0 ? "+" : ""}${tempSslSE} pkt`;
  explanations.push({
    id: "ssl",
    icon: Lock,
    label: "Szyfrowanie (SSL)",
    valueText: sslVT,
    impact: sslI,
    details: sslDet,
    scoreEffect: sslSETxt,
    longDesc:
      "Certyfikat SSL zapewnia szyfrowanie danych przesyłanych między Tobą a stroną, chroniąc je przed podsłuchem. Strony bez SSL (HTTP) lub z wygasłym/niepoprawnym certyfikatem są mniej bezpieczne, szczególnie jeśli podajesz na nich wrażliwe dane.",
  });

  let urlAiSEV = 0;
  if (urlAiAnalysis === null) {
    urlAiSEV = PTS.urlAi.error;
    explanations.push({
      id: "aiUrl",
      icon: ShieldQuestion,
      label: "Analiza AI URL",
      valueText: <span className="text-red-500">Błąd analizy</span>,
      impact: "negative",
      scoreEffect: `${urlAiSEV} pkt`,
      details:
        "Nie udało się przeprowadzić analizy AI dla tego URL z powodu błędu.",
      longDesc:
        "Czasami analiza AI może się nie udać z przyczyn technicznych. Nie wpływa to na inne aspekty oceny, ale uniemożliwia wykrycie specyficznych dla URL wzorców phishingu.",
    });
  } else if (urlAiAnalysis) {
    let aiI: ExplanationImpact = "neutral";
    if (urlAiAnalysis.is_phishing) {
      aiI = "negative";
      if (urlAiAnalysis.confidence > 0.9) urlAiSEV = PTS.urlAi.ph;
      else urlAiSEV = PTS.urlAi.pm;
    } else if (urlAiAnalysis.confidence > 0.9) {
      urlAiSEV = PTS.urlAi.lh;
      aiI = "positive";
    } else {
      urlAiSEV = PTS.urlAi.ll;
      aiI = "neutral";
    }
    explanations.push({
      id: "aiUrl",
      icon: ShieldQuestion,
      label: "Analiza AI URL",
      valueText: `${urlAiAnalysis.label} (${(
        urlAiAnalysis.confidence * 100
      ).toFixed(0)}%)`,
      impact: aiI,
      scoreEffect: `${urlAiSEV > 0 ? "+" : ""}${urlAiSEV} pkt`,
      details: `Model AI ocenił URL jako ${urlAiAnalysis.label.toLowerCase()} z ${(
        urlAiAnalysis.confidence * 100
      ).toFixed(0)}% pewnością.`,
      longDesc:
        "Sztuczna inteligencja analizuje strukturę i komponenty adresu URL w poszukiwaniu wzorców typowych dla phishingu lub złośliwych stron.",
    });
  } else {
    explanations.push({
      id: "aiUrl",
      icon: ShieldQuestion,
      label: "Analiza AI URL",
      valueText: <span className="text-gray-500">Niedostępna</span>,
      impact: "neutral",
      scoreEffect: "0 pkt",
      details:
        "Analiza AI adresu URL nie została przeprowadzona lub jest niedostępna dla tej strony.",
    });
  }
  score += urlAiSEV;

  let cAiL: React.ReactNode = <span className="text-gray-500">N/A</span>;
  let cAiI: ExplanationImpact = "neutral",
    cAiSEV = 0;
  let cAiDet =
    "Analiza treści strony nie została przeprowadzona lub brakło tekstu.";
  let cAiLD: React.ReactNode =
    "Analiza treści strony wyszukuje fragmenty mogące wskazywać na oszustwo. Pokazujemy do 3 najbardziej podejrzanych fragmentów, jeśli takie istnieją.";
  const sChunksI: { label: string; conf: number; chunk: string }[] = [];

  if (contentAiAnalyses === null) {
    cAiL = <span className="text-red-500">Błąd analizy treści</span>;
    cAiI = "negative";
    cAiSEV = PTS.cAi.error;
    cAiDet = "Wystąpił błąd podczas próby analizy treści strony.";
  } else if (contentAiAnalyses && contentAiAnalyses.length > 0) {
    let pC = 0,
      hCP = false,
      tCS = 0;
    contentAiAnalyses.forEach((ca) => {
      if (ca.is_phishing) {
        pC++;
        tCS += ca.confidence;
        if (ca.confidence > 0.9) hCP = true;
        sChunksI.push({
          label: ca.label,
          conf: ca.confidence,
          chunk: ca.originalChunk,
        });
      }
    });
    if (hCP) {
      cAiSEV = PTS.cAi.ah;
      cAiI = "negative";
      cAiL = <span className="text-red-500 font-semibold">Podejrzane!</span>;
      cAiDet = `Wykryto fragmenty treści o wysokim prawdopodobieństwie phishingu (${pC}/${contentAiAnalyses.length}).`;
    } else if (pC > 0) {
      const avgC = tCS / pC;
      if (avgC > 0.5) {
        cAiSEV = PTS.cAi.ap;
        cAiI = "negative";
        cAiL = "Podejrzane fragmenty";
        cAiDet = `Wykryto ${pC} z ${contentAiAnalyses.length} fragmentów jako potencjalnie phishingowe.`;
      } else {
        cAiI = "info";
        cAiL = "Niejednoznaczne";
        cAiDet = `Niektóre fragmenty (${pC}/${contentAiAnalyses.length}) wydają się niejednoznaczne.`;
      }
    } else {
      cAiSEV = PTS.cAi.ml;
      cAiI = "positive";
      cAiL = "Treść OK";
      cAiDet = `Analiza treści (${contentAiAnalyses.length} fragmentów) nie wykazała znamion phishingu.`;
    }

    if (sChunksI.length > 0) {
      cAiLD = (
        <>
          {typeof cAiLD === "string" ? <p>{cAiLD}</p> : cAiLD}
          <p className="mt-2 font-semibold">Podejrzane fragmenty:</p>
          <ul className="list-disc pl-5 max-h-24 overflow-y-auto text-xs custom-scrollbar">
            {sChunksI.slice(0, 3).map((s, i) => (
              <li key={i} title={s.chunk} className="mb-1">
                <span
                  className={`font-semibold ${
                    s.label === "PHISHING" ? "text-red-600" : "text-gray-700"
                  }`}
                >
                  "{s.chunk.substring(0, 50)}..."
                </span>
                <span className="text-gray-500 ml-1">
                  ({s.label} {(s.conf * 100).toFixed(0)}%)
                </span>
              </li>
            ))}
          </ul>
          {sChunksI.length > 3 && (
            <p className="text-xs mt-1">...i {sChunksI.length - 3} więcej.</p>
          )}
        </>
      );
    }
  } else if (contentAiAnalyses && contentAiAnalyses.length === 0) {
    cAiSEV = PTS.cAi.noContent;
    cAiI = "info";
    cAiL = "Brak tekstu";
    cAiDet =
      "Nie znaleziono wystarczającej ilości tekstu na stronie do przeprowadzenia pełnej analizy treści.";
  }
  score += cAiSEV;
  explanations.push({
    id: "contentAi",
    icon: MessageSquareQuote,
    label: "Analiza AI treści",
    valueText: cAiL,
    impact: cAiI,
    scoreEffect: `${cAiSEV > 0 ? "+" : ""}${cAiSEV} pkt`,
    details: cAiDet,
    longDesc: cAiLD,
  });

  let onBl = false,
    blSEV = 0;
  const blSrc: string[] = [];
  if (analysisData.blacklist_checks) {
    analysisData.blacklist_checks.forEach((c) => {
      if (c.is_listed) {
        onBl = true;
        blSrc.push(c.source);
      }
    });
  }
  if (onBl) {
    blSEV = PTS.bl.l;
    explanations.push({
      id: "blacklist",
      icon: ShieldAlert,
      label: "Listy zagrożeń",
      valueText: `Na listach: ${blSrc.join(", ")}`,
      impact: "negative",
      scoreEffect: `${blSEV} pkt`,
      details:
        "Znalezienie na publicznej liście zagrożeń jest silnym sygnałem ostrzegawczym.",
      longDesc:
        "Te listy są kompilowane przez organizacje bezpieczeństwa i zawierają strony znane z hostowania malware, phishingu lub innych niebezpiecznych treści. Obecność na takiej liście oznacza wysokie ryzyko.",
    });
  } else {
    blSEV = PTS.bl.c;
    explanations.push({
      id: "blacklist",
      icon: ShieldCheck,
      label: "Listy zagrożeń",
      valueText: "Czysto",
      impact: "positive",
      scoreEffect: `+${blSEV} pkt`,
      details: "Nie znaleziono na znanych listach zagrożeń.",
      longDesc:
        "Brak wpisów na głównych listach zagrożeń to dobry znak, ale nie gwarantuje 100% bezpieczeństwa, zwłaszcza dla nowych stron.",
    });
  }
  score += blSEV;

  let ipUrlSEV = 0;
  if (analysisData.is_ip_address_in_url) {
    ipUrlSEV = PTS.ip;
    explanations.push({
      id: "ipInUrl",
      icon: Network,
      label: "Adres IP w URL",
      valueText: "Tak",
      impact: "negative",
      scoreEffect: `${ipUrlSEV} pkt`,
      details:
        "Używanie adresu IP zamiast nazwy domenowej jest częstą taktyką w phishingu.",
      longDesc:
        "Legalne strony rzadko używają adresów IP bezpośrednio w linkach widocznych dla użytkownika. Może to być próba obejścia filtrów opartych na nazwach domenowych lub ukrycia prawdziwego celu linku.",
    });
  } else {
    explanations.push({
      id: "ipInUrl",
      icon: Network,
      label: "Adres IP w URL",
      valueText: "Nie",
      impact: "positive",
      details: "URL używa standardowej nazwy domenowej.",
      scoreEffect: "+0 pkt",
    });
  }
  score += ipUrlSEV;

  const finalScore = Math.max(MIN, Math.min(MAX, Math.round(score)));
  console.log(
    `[ScoreCalc] Final calculated score: ${finalScore} (raw score before clamp: ${score})`
  );
  return { score: finalScore, explanations };
}

--------------------
File: C:\Users\mikol\Desktop\IsThisPhishy-addon\src\popup\utils\helpers.ts
--------------------
// src/popup/utils/helpers.ts
export const formatDomainAge = (days: number | null | undefined): string => {
  if (days === null || typeof days === "undefined") return "N/A";
  if (days < 0) return "Data przyszła (podejrzane)";
  if (days < 30) return `${days} dni (bardzo młoda)`;
  if (days < 180) return `${Math.floor(days / 30)} mies. (młoda)`;
  if (days < 365) return `${Math.floor(days / 30)} mies. (poniżej roku)`;
  const y = Math.floor(days / 365);
  const m = Math.floor((days % 365) / 30);
  return `${y} ${y === 1 ? "r." : "l."}${m > 0 ? ` i ${m}m.` : ""} (dojrzała)`;
};

export const getDomainFromUrl = (url: string): string => {
  try {
    const u = new URL(url);
    return u.hostname.replace(/^www\./, "");
  } catch {
    return "";
  }
};

export const getScoreVisuals = (
  score: number | null,
  isLoading: boolean = false,
  errorOccurred: boolean = false
): {
  bgColor: string;
  textColor: string;
  ringColor: string;
  description: string;
  scoreText: string | React.ReactElement;
} => {
  let bgColor = "bg-gray-400";
  let textColor = "text-gray-700";
  let ringColor = "ring-gray-400";
  let description = "Analizowanie...";
  let scoreText: string | React.ReactElement = "?";

  if (isLoading && score === null && !errorOccurred) {
    description = "Analizowanie...";
    // scoreText pozostaje "?" lub można dać ikonę loadera, ale to w komponencie
  } else if (errorOccurred && score === null) {
    description = "Błąd Oceny";
    bgColor = "bg-red-500";
    textColor = "text-white";
    ringColor = "ring-red-500";
  } else if (score === null && !isLoading) {
    description = "Brak Oceny";
  } else if (score !== null) {
    scoreText = score.toString();
    if (score < 40) {
      bgColor = "bg-red-500";
      textColor = "text-white";
      ringColor = "ring-red-500";
      description = "Wysokie Ryzyko";
    } else if (score < 70) {
      bgColor = "bg-yellow-500";
      textColor = "text-black";
      ringColor = "ring-yellow-500";
      description = "Podwyższone Ryzyko";
    } else {
      bgColor = "bg-green-500";
      textColor = "text-white";
      ringColor = "ring-green-500";
      description = "Niskie Ryzyko";
    }
  }

  return { bgColor, textColor, ringColor, description, scoreText };
};

--------------------
File: C:\Users\mikol\Desktop\IsThisPhishy-addon\src\styles\globals.css
--------------------
@tailwind base;
@tailwind components;
@tailwind utilities;

--------------------
File: C:\Users\mikol\Desktop\IsThisPhishy-addon\src\types\domainAnalysis.ts
--------------------
export interface SSLInfo {
  issuer: { [key: string]: string } | null;
  subject: { [key: string]: string } | null;
  version: number | null;
  serial_number: string | null;
  not_before: string | null;
  not_after: string | null;
}

export interface WhoisInfo {
  registrar: string | null;
  creation_date: string | null;
  expiration_date: string | null;
  updated_date: string | null;
  name_servers: string[] | null;
  emails: string[] | null;
  status: string[] | null;
}

export interface BlacklistCheckResult {
  source: string;
  is_listed: boolean;
  details: unknown | null;
}

export interface DomainAnalysisDetails {
  domain_name: string | null;
  parsed_url_scheme: string | null;
  parsed_url_path: string | null;
  parsed_url_query: string | null;
  dns_records: { [key: string]: string[] } | null;
  ssl_info: SSLInfo | null;
  whois_info: WhoisInfo | null;
  domain_actual_age_days: number | null;
  blacklist_checks: BlacklistCheckResult[] | null;
  is_ip_address_in_url: boolean;
  error: string | null;
}

export interface PhishingTextAnalysis {
  is_phishing: boolean;
  confidence: number;
  label: string;
}

export interface PageContentAiAnalysis extends PhishingTextAnalysis {
  chunkIndex: number; // Indeks analizowanego fragmentu
  originalChunk: string; // Fragment tekstu, który był analizowany
}

export type StoredDomainData = {
  analysis?: DomainAnalysisDetails;
  urlTextAnalysis?: PhishingTextAnalysis | null; // Zmieniona nazwa dla jasności
  pageContentAnalyses?: PageContentAiAnalysis[] | null; // NOWE: Wyniki analizy treści strony
  lastChecked: number;
  error?: string;
  isLoading?: boolean;
};

