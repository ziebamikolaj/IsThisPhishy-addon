Directory Structure:
--------------------
|-- public
-- src
    |-- background
    |-- components
    |   -- ui
    |-- content
    |-- lib
    |-- popup
    |   |-- components
    |   |-- consts
    |   |-- hooks
    |   |-- services
    |   -- utils
    |-- styles
    -- types
--------------------
File Contents:
--------------------
--------------------
File: C:\Users\zieba\Desktop\stuff\IsThisPhishy-addon\.gitignore
--------------------
node_modules

--------------------
File: C:\Users\zieba\Desktop\stuff\IsThisPhishy-addon\components.json
--------------------
{
  "$schema": "https://ui.shadcn.com/schema.json",
  "style": "default",
  "rsc": true,
  "tsx": true,
  "tailwind": {
    "config": "tailwind.config.ts",
    "css": "src/app/styles/globals.css",
    "baseColor": "neutral",
    "cssVariables": true,
    "prefix": ""
  },
  "aliases": {
    "components": "@/components",
    "utils": "@/lib/utils",
    "ui": "@/components/ui",
    "lib": "@/lib",
    "hooks": "@/hooks"
  }
}

--------------------
File: C:\Users\zieba\Desktop\stuff\IsThisPhishy-addon\eslint.config.js
--------------------
import js from '@eslint/js'
import globals from 'globals'
import reactHooks from 'eslint-plugin-react-hooks'
import reactRefresh from 'eslint-plugin-react-refresh'
import tseslint from 'typescript-eslint'

export default tseslint.config(
  { ignores: ['dist'] },
  {
    extends: [js.configs.recommended, ...tseslint.configs.recommended],
    files: ['**/*.{ts,tsx}'],
    languageOptions: {
      ecmaVersion: 2020,
      globals: globals.browser,
    },
    plugins: {
      'react-hooks': reactHooks,
      'react-refresh': reactRefresh,
    },
    rules: {
      ...reactHooks.configs.recommended.rules,
      'react-refresh/only-export-components': [
        'warn',
        { allowConstantExport: true },
      ],
    },
  },
)

--------------------
File: C:\Users\zieba\Desktop\stuff\IsThisPhishy-addon\index.html
--------------------
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <!-- Jeśli masz ikonę specyficzną dla popupu, możesz ją tu dodać -->
    <title>IsThisFishy Popup</title>
    <!-- Plugin powinien automatycznie wstrzyknąć CSS -->
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="./popup.tsx"></script>
    <!-- Wskazuje na plik TSX popupu -->
  </body>
</html>

--------------------
File: C:\Users\zieba\Desktop\stuff\IsThisPhishy-addon\postcss.config.js
--------------------
export default {
  plugins: {
    tailwindcss: {},
    autoprefixer: {},
  },
};

--------------------
File: C:\Users\zieba\Desktop\stuff\IsThisPhishy-addon\README.md
--------------------
# Hack yeah 2024 - Is this fishy ?

## Extension:

- Vite
- React
- TypeScript

## Frontend:

- Next.js
- React
- TypeScript
- **Schema validation**
  - Zod
- **Form handling**
  - React Hook Form
- **Query handling**
  - TanStack Query
- **UI**
  - Tailwind CSS
  - shadcn/ui
- **Emails template** (optional)
  - React email

## Backend:

- Next.js API
- Drizzle ORM
- **File hosting** (optional)
  - AWS S3
- **Email sending** (optional)
  - AWS SES
- **Phone notifications** (optional)
  - AWS SNS

--------------------
File: C:\Users\zieba\Desktop\stuff\IsThisPhishy-addon\tailwind.config.ts
--------------------
/** @type {import('tailwindcss').Config} */
export default {
  darkMode: ["class"],
  content: ["./src/**/*.{js,jsx,ts,tsx}", "./src/**/*.html"],
  theme: {
    extend: {
      borderRadius: {
        lg: "var(--radius)",
        md: "calc(var(--radius) - 2px)",
        sm: "calc(var(--radius) - 4px)",
      },
      colors: {
        background: "hsl(var(--background))",
        foreground: "hsl(var(--foreground))",
        card: {
          DEFAULT: "hsl(var(--card))",
          foreground: "hsl(var(--card-foreground))",
        },
        popover: {
          DEFAULT: "hsl(var(--popover))",
          foreground: "hsl(var(--popover-foreground))",
        },
        primary: {
          DEFAULT: "hsl(var(--primary))",
          foreground: "hsl(var(--primary-foreground))",
        },
        secondary: {
          DEFAULT: "hsl(var(--secondary))",
          foreground: "hsl(var(--secondary-foreground))",
        },
        muted: {
          DEFAULT: "hsl(var(--muted))",
          foreground: "hsl(var(--muted-foreground))",
        },
        accent: {
          DEFAULT: "hsl(var(--accent))",
          foreground: "hsl(var(--accent-foreground))",
        },
        destructive: {
          DEFAULT: "hsl(var(--destructive))",
          foreground: "hsl(var(--destructive-foreground))",
        },
        border: "hsl(var(--border))",
        input: "hsl(var(--input))",
        ring: "hsl(var(--ring))",
        chart: {
          "1": "hsl(var(--chart-1))",
          "2": "hsl(var(--chart-2))",
          "3": "hsl(var(--chart-3))",
          "4": "hsl(var(--chart-4))",
          "5": "hsl(var(--chart-5))",
        },
      },
    },
  },
  plugins: [import("tailwindcss-animate")],
};

--------------------
File: C:\Users\zieba\Desktop\stuff\IsThisPhishy-addon\tsconfig.json
--------------------
{
  "compilerOptions": {
    "target": "ESNext",
    "lib": ["DOM", "DOM.Iterable", "ESNext"],
    "allowJs": true,
    "skipLibCheck": true,
    "esModuleInterop": true,
    "allowSyntheticDefaultImports": true,
    "strict": true,
    "forceConsistentCasingInFileNames": true,
    "module": "ESNext",
    "moduleResolution": "Node",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "noEmit": true,
    "jsx": "react-jsx",
    "baseUrl": ".",
    "paths": {
      "@/*": ["./src/*"]
    }
  },
  "include": ["src"],
  "exclude": ["node_modules", "dist"]
}

--------------------
File: C:\Users\zieba\Desktop\stuff\IsThisPhishy-addon\tsconfig.tsbuildinfo
--------------------
{"root":["./src/App.tsx","./src/main.tsx","./src/vite-env.d.ts","./src/background/background.ts","./src/content/content.ts","./src/popup/main.tsx"],"version":"5.6.2"}

--------------------
File: C:\Users\zieba\Desktop\stuff\IsThisPhishy-addon\vite.config.ts
--------------------
import { defineConfig } from "vite";
import react from "@vitejs/plugin-react";
import webExtension from "vite-plugin-web-extension";
import path from "node:path";

function generateManifest() {
  return {
    manifest_version: 3,
    name: "IsThisFishy Extension (Dev)",
    version: "1.0.3",
    description: "A browser extension to detect fishy content - DEV MODE",
    action: {
      default_popup: "src/popup/index.html",
    },
    background: {
      service_worker: "src/background/background.ts",
      type: "module",
    },
    content_scripts: [
      {
        matches: ["<all_urls>"],
        js: ["src/content/content.ts"],
      },
    ],
    icons: {
      "16": "icon.png",
      "48": "icon.png",
      "128": "icon.png",
    },
    permissions: ["activeTab", "storage", "tabs", "scripting"],
    host_permissions: ["<all_urls>"],
  };
}

export default defineConfig(({ mode }) => {
  const isDevelopment = mode === "development";
  return {
    plugins: [
      react(),
      webExtension({
        manifest: generateManifest,
        // verbose: true, // Odkomentuj dla debugowania problemów z pluginem
      }),
    ],
    resolve: { alias: { "@": path.resolve(__dirname, "./src") } },
    build: {
      outDir: path.resolve(__dirname, "dist"),
      sourcemap: isDevelopment ? "inline" : false,
      emptyOutDir: true,
    },
    server: { hmr: { protocol: "ws", host: "localhost", port: 5174 } }, // Zmieniono port na domyślny Vite, jeśli nie używasz 5000 specjalnie
  };
});

--------------------
File: C:\Users\zieba\Desktop\stuff\IsThisPhishy-addon\src\main.tsx
--------------------
import React from "react";
import ReactDOM from "react-dom/client";

import "./styles/globals.css";

import { PopupContent } from "./popup/popup-content";

ReactDOM.createRoot(document.getElementById("root") as HTMLElement).render(
  <React.StrictMode>
    <PopupContent></PopupContent>
  </React.StrictMode>,
);

--------------------
File: C:\Users\zieba\Desktop\stuff\IsThisPhishy-addon\src\vite-env.d.ts
--------------------
/// <reference types="vite/client" />

--------------------
File: C:\Users\zieba\Desktop\stuff\IsThisPhishy-addon\src\background\background.ts
--------------------
// src/background/background.ts
import {
  DomainAnalysisDetails,
  PhishingTextAnalysis,
  PageContentAiAnalysis,
  StoredDomainData,
} from "@/types/domainAnalysis";
import { calculateTrustScore } from "@/popup/services/scoreCalculator";

const API_BASE_URL = "http://127.0.0.1:8000/api/v1";

const getDomainFromUrl = (url: string): string => {
  try {
    const u = new URL(url);
    return u.hostname.replace(/^www\./, "");
  } catch {
    return "";
  }
};

const updateBadge = (text: string, color: string = "#777777") => {
  try {
    chrome.action.setBadgeText({ text });
    chrome.action.setBadgeBackgroundColor({ color });
  } catch (e) {
    console.warn("[BG] Failed to update badge.", e);
  }
};

const updateBadgeWithScore = (
  data: StoredDomainData,
  urlForAnalysis: string
) => {
  if (!data) return;
  const { score } = calculateTrustScore(data, urlForAnalysis);
  if (score !== null) {
    let color = "#10B981";
    if (score < 40) color = "#EF4444";
    else if (score < 70) color = "#F59E0B";
    updateBadge(score.toString(), color);
  } else if (data.error) {
    updateBadge("!", "#EF4444");
  } else {
    updateBadge("?", "#777777");
  }
};

const fetchTextAnalysis = async (
  textToAnalyze: string
): Promise<PhishingTextAnalysis | null> => {
  try {
    const response = await fetch(`${API_BASE_URL}/check_phishing_text`, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ text_to_analyze: textToAnalyze }),
    });
    if (!response.ok) return null;
    return await response.json();
  } catch (e) {
    console.error("[BG] fetchTextAnalysis Network Error:", e);
    return null;
  }
};

const performFullAnalysis = async (
  urlToAnalyze: string,
  contentChunksForAnalysis: string[] = []
): Promise<StoredDomainData> => {
  const domain = getDomainFromUrl(urlToAnalyze);
  if (!domain) return { error: "Invalid domain", lastChecked: Date.now() };

  updateBadge("...", "#F59E0B");

  try {
    const [domainDetailsResponse, urlTextAnalysisResult] = await Promise.all([
      fetch(`${API_BASE_URL}/analyze_domain_details`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ url: urlToAnalyze }),
      }),
      fetchTextAnalysis(urlToAnalyze),
    ]);

    if (!domainDetailsResponse.ok) {
      return {
        error: "API Error (domain details)",
        lastChecked: Date.now(),
      };
    }
    const domainAnalysis: DomainAnalysisDetails =
      await domainDetailsResponse.json();

    console.log(domainAnalysis);
    if (domainAnalysis.error) {
      return { error: domainAnalysis.error, lastChecked: Date.now() };
    }

    let pageContentAiResults: PageContentAiAnalysis[] = [];
    if (contentChunksForAnalysis.length > 0) {
      const analysisPromises = contentChunksForAnalysis.map(
        async (chunk, idx) => {
          const result = await fetchTextAnalysis(chunk);
          if (result) {
            return {
              ...result,
              chunkIndex: idx,
              originalChunk: chunk.substring(0, 100) + "...",
            };
          }
          return null;
        }
      );
      pageContentAiResults = (await Promise.all(analysisPromises)).filter(
        (r) => r !== null
      ) as PageContentAiAnalysis[];
    }

    const storedData: StoredDomainData = {
      analysis: domainAnalysis,
      urlTextAnalysis: urlTextAnalysisResult,
      pageContentAnalyses: pageContentAiResults,
      lastChecked: Date.now(),
    };

    chrome.storage.local.set({ [domain]: storedData });
    updateBadgeWithScore(storedData, urlToAnalyze);
    return storedData;
  } catch (e) {
    const errorMsg = e instanceof Error ? e.message : String(e);
    updateBadge("!", "#EF4444");
    return {
      error: `Network/Parsing error: ${errorMsg}`,
      lastChecked: Date.now(),
    };
  }
};

// This listener is now the main entry point for automatic analysis.
chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {
  if (message.action === "analyzePageContent") {
    console.log(`[BG] Received content for analysis from ${message.url}`);
    performFullAnalysis(message.url, message.contentChunks)
      .then((data) => {
        chrome.runtime
          .sendMessage({
            action: "analysisUpdated",
            domain: getDomainFromUrl(message.url),
            data,
            forUrl: message.url,
          })
          .catch(() => {}); // Suppress "no receiving end" error if popup is closed
        sendResponse({ success: true });
      })
      .catch((error) => sendResponse({ success: false, error: error.message }));
    return true; // Keep the message channel open for async response
  }

  // This listener handles the manual refresh from the popup.
  if (message.action === "requestAnalysisForCurrentTab") {
    const urlToAnalyze = message.url;
    const tabId = message.tabId || sender.tab?.id;

    if (urlToAnalyze && tabId) {
      console.log(
        `[BG] Manual refresh requested for ${urlToAnalyze} on tab ${tabId}`
      );
      updateBadge("...", "#F59E0B");
      // Ask the content script to re-send its data.
      chrome.tabs.sendMessage(tabId, { action: "getTextContentFromPage" });
      sendResponse({ status: "refresh_triggered" });
    } else {
      sendResponse({ error: "No active tab/URL to refresh." });
    }
    return true;
  }

  return false;
});

// When the user switches to a different tab, check for cached data.
chrome.tabs.onActivated.addListener(async (activeInfo) => {
  chrome.tabs.get(activeInfo.tabId, (tab) => {
    if (tab.url) {
      const domain = getDomainFromUrl(tab.url);
      chrome.storage.local.get(domain, (result) => {
        const cachedData: StoredDomainData | undefined = result[domain];
        if (cachedData) {
          console.log(`[BG] onActivated: Found cached data for ${domain}`);
          updateBadgeWithScore(cachedData, tab.url!);
        } else {
          // If no cache, clear the badge. The content script will send data if available.
          updateBadge("", "#777777");
        }
      });
    }
  });
});
chrome.runtime.onInstalled.addListener(async (details) => {
  if (details.reason === "install" || details.reason === "update") {
    console.log(
      "[BG] Extension installed/updated. Injecting content scripts into existing tabs."
    );

    // Get all existing tabs
    const tabs = await chrome.tabs.query({
      // We only want to inject into normal http/https tabs
      url: ["http://*/*", "https://*/*"],
      status: "complete", // Only inject into tabs that have finished loading
    });

    for (const tab of tabs) {
      if (tab.id) {
        try {
          // Programmatically inject the content script
          await chrome.scripting.executeScript({
            target: { tabId: tab.id },
            files: ["src/content/content.js"],
          });
          console.log(`[BG] Injected content script into tab ${tab.id}`);
        } catch (err) {
          // This might fail on certain browser-protected pages, which is fine.
          console.warn(`[BG] Failed to inject script into tab ${tab.id}:`, err);
        }
      }
    }
  }
});

console.log("[BG] Background script loaded and listeners attached (v1.2.1).");

--------------------
File: C:\Users\zieba\Desktop\stuff\IsThisPhishy-addon\src\components\ui\button.tsx
--------------------
import * as React from "react";
import { Slot } from "@radix-ui/react-slot";
import { cva } from "class-variance-authority";

import { cn } from "@/lib/utils";

const buttonVariants = cva(
  "inline-flex items-center justify-center whitespace-nowrap rounded-md text-sm font-medium ring-offset-background transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50",
  {
    variants: {
      variant: {
        default: "bg-primary text-primary-foreground hover:bg-primary/90",
        destructive:
          "bg-destructive text-destructive-foreground hover:bg-destructive/90",
        outline:
          "border border-input bg-background hover:bg-accent hover:text-accent-foreground",
        secondary:
          "bg-secondary text-secondary-foreground hover:bg-secondary/80",
        ghost: "hover:bg-accent hover:text-accent-foreground",
        link: "text-primary underline-offset-4 hover:underline",
      },
      size: {
        default: "h-10 px-4 py-2",
        sm: "h-9 rounded-md px-3",
        lg: "h-11 rounded-md px-8",
        icon: "h-10 w-10",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  }
);

interface ButtonProps extends React.ButtonHTMLAttributes<HTMLButtonElement> {
  variant?:
    | "default"
    | "destructive"
    | "outline"
    | "secondary"
    | "ghost"
    | "link";
  size?: "default" | "sm" | "lg";
  asChild?: boolean;
}

const Button = React.forwardRef<HTMLButtonElement, ButtonProps>(
  ({ className, variant, size, asChild = false, ...props }, ref) => {
    const Comp = asChild ? Slot : "button";
    return (
      <Comp
        className={cn(buttonVariants({ variant, size, className }))}
        ref={ref}
        {...props}
      />
    );
  }
);
Button.displayName = "Button";

export { Button, buttonVariants };

--------------------
File: C:\Users\zieba\Desktop\stuff\IsThisPhishy-addon\src\components\ui\label.tsx
--------------------
"use client"

import * as React from "react"
import * as LabelPrimitive from "@radix-ui/react-label"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const labelVariants = cva(
  "text-sm font-medium leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70"
)

const Label = React.forwardRef<
  React.ElementRef<typeof LabelPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof LabelPrimitive.Root> &
    VariantProps<typeof labelVariants>
>(({ className, ...props }, ref) => (
  <LabelPrimitive.Root
    ref={ref}
    className={cn(labelVariants(), className)}
    {...props}
  />
))
Label.displayName = LabelPrimitive.Root.displayName

export { Label }

--------------------
File: C:\Users\zieba\Desktop\stuff\IsThisPhishy-addon\src\components\ui\progress.tsx
--------------------
"use client";

import * as React from "react";
import * as ProgressPrimitive from "@radix-ui/react-progress";

import { cn } from "@/lib/utils";

const Progress = React.forwardRef<
  React.ElementRef<typeof ProgressPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof ProgressPrimitive.Root>
>(({ className, value, ...props }, ref) => (
  <ProgressPrimitive.Root
    ref={ref}
    className="relative h-2 w-full overflow-hidden rounded-full bg-secondary shadow-lg "
    {...props}
  >
    <ProgressPrimitive.Indicator
      className={cn(`h-full w-full flex-1 transition-all`, className)}
      style={{ transform: `translateX(-${100 - (value ?? 0)}%)` }}
    />
  </ProgressPrimitive.Root>
));
Progress.displayName = ProgressPrimitive.Root.displayName;

export { Progress };

--------------------
File: C:\Users\zieba\Desktop\stuff\IsThisPhishy-addon\src\components\ui\switch.tsx
--------------------
"use client"

import * as React from "react"
import * as SwitchPrimitives from "@radix-ui/react-switch"

import { cn } from "@/lib/utils"

const Switch = React.forwardRef<
  React.ElementRef<typeof SwitchPrimitives.Root>,
  React.ComponentPropsWithoutRef<typeof SwitchPrimitives.Root>
>(({ className, ...props }, ref) => (
  <SwitchPrimitives.Root
    className={cn(
      "peer inline-flex h-6 w-11 shrink-0 cursor-pointer items-center rounded-full border-2 border-transparent transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 focus-visible:ring-offset-background disabled:cursor-not-allowed disabled:opacity-50 data-[state=checked]:bg-primary data-[state=unchecked]:bg-input",
      className
    )}
    {...props}
    ref={ref}
  >
    <SwitchPrimitives.Thumb
      className={cn(
        "pointer-events-none block h-5 w-5 rounded-full bg-background shadow-lg ring-0 transition-transform data-[state=checked]:translate-x-5 data-[state=unchecked]:translate-x-0"
      )}
    />
  </SwitchPrimitives.Root>
))
Switch.displayName = SwitchPrimitives.Root.displayName

export { Switch }

--------------------
File: C:\Users\zieba\Desktop\stuff\IsThisPhishy-addon\src\components\ui\tooltip.tsx
--------------------
"use client";

import * as React from "react";
import * as TooltipPrimitive from "@radix-ui/react-tooltip";

import { cn } from "@/lib/utils";

const TooltipProvider = TooltipPrimitive.Provider;

const Tooltip = TooltipPrimitive.Root;

const TooltipTrigger = TooltipPrimitive.Trigger;

const TooltipContent = React.forwardRef<
  React.ElementRef<typeof TooltipPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof TooltipPrimitive.Content>
>(({ className, sideOffset = 4, ...props }, ref) => (
  <TooltipPrimitive.Content
    ref={ref}
    sideOffset={sideOffset}
    className={cn(
      "z-50 overflow-hidden rounded-md border bg-popover px-3 py-1.5 text-sm text-popover-foreground shadow-md animate-in fade-in-0 zoom-in-95 data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=closed]:zoom-out-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
      className,
    )}
    {...props}
  />
));
TooltipContent.displayName = TooltipPrimitive.Content.displayName;

export { Tooltip, TooltipTrigger, TooltipContent, TooltipProvider };

--------------------
File: C:\Users\zieba\Desktop\stuff\IsThisPhishy-addon\src\content\content.ts
--------------------
// src/content/content.ts
import { Readability } from "@mozilla/readability";
import "../styles/globals.css";

const MAX_CHUNKS_FOR_ANALYSIS = 5;
const CHUNK_SIZE = 2000;

function extractAndSendContent() {
  // Use a clone of the document to avoid side-effects on the live page.
  const documentClone = document.cloneNode(true) as Document;
  const reader = new Readability(documentClone);
  const article = reader.parse();

  if (!article || !article.textContent) {
    console.log(
      "[ContentScript] Readability found no content. Sending empty chunks."
    );
    // Still send a message so the background script knows content analysis was attempted but failed.
    chrome.runtime.sendMessage({
      action: "analyzePageContent",
      url: window.location.href,
      contentChunks: [],
    });
    return;
  }

  const cleanText = article.textContent.replace(/\s+/g, " ").trim();
  const chunks: string[] = [];
  if (cleanText.length > 0) {
    for (let i = 0; i < cleanText.length; i += CHUNK_SIZE) {
      chunks.push(cleanText.substring(i, i + CHUNK_SIZE));
    }
  }

  const finalChunks = chunks.slice(0, MAX_CHUNKS_FOR_ANALYSIS);
  console.log(
    `[ContentScript] Proactively sending ${finalChunks.length} chunks to background.`
  );

  chrome.runtime.sendMessage(
    {
      action: "analyzePageContent",
      url: window.location.href,
      contentChunks: finalChunks,
    },
    (response) => {
      if (chrome.runtime.lastError) {
        console.warn(
          `[CS] Error sending content: ${chrome.runtime.lastError.message}`
        );
      } else if (response && !response.success) {
        console.warn(
          "[CS] Background failed to process content:",
          response.error
        );
      }
    }
  );
}

// This listener is now ONLY for handling manual refresh requests from the popup.
chrome.runtime.onMessage.addListener((request, sender, sendResponse) => {
  if (request.action === "getTextContentFromPage") {
    console.log("[ContentScript] Received manual refresh request.");
    extractAndSendContent();
    sendResponse({ status: "processing_initiated_by_manual_refresh" });
    return true;
  }
  return false;
});

// Proactively run the analysis when the script is injected and the page is ready.
if (
  document.readyState === "complete" ||
  document.readyState === "interactive"
) {
  // Small delay to ensure the page is fully settled.
  setTimeout(extractAndSendContent, 500);
} else {
  window.addEventListener(
    "load",
    () => {
      setTimeout(extractAndSendContent, 500);
    },
    { once: true }
  );
}

console.log("[ContentScript] IsThisPhishy v1.2.0 loaded (proactive mode).");

--------------------
File: C:\Users\zieba\Desktop\stuff\IsThisPhishy-addon\src\lib\utils.ts
--------------------
import type { ClassValue } from "clsx";
import { clsx } from "clsx";
import { twMerge } from "tailwind-merge";

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs));
}

--------------------
File: C:\Users\zieba\Desktop\stuff\IsThisPhishy-addon\src\popup\index.html
--------------------
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="icon" type="image/png" href="/icon.png" />
    <title>IsThisFishy Extension</title>
    <link rel="stylesheet" href="style.css" />
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="./popup.tsx"></script>
  </body>
</html>

--------------------
File: C:\Users\zieba\Desktop\stuff\IsThisPhishy-addon\src\popup\popup-content.tsx
--------------------
// src/popup/popup-content.tsx
"use client";
import React from "react";
import { RefreshCw, Loader2, Info } from "lucide-react";
import { Button } from "@/components/ui/button";
import { useAnalysisData } from "./hooks/useAnalysisData";
import { Header, Footer } from "./components/Header";
import { LoadingIndicator } from "./components/LoadingIndicator";
import { ErrorDisplay } from "./components/ErrorDisplay";
import { ScoreDisplay } from "./components/ScoreDisplay";
import { ScoreExplanationsList } from "./components/ScoreExplanations";

export const PopupContent = () => {
  const {
    storedData,
    currentUrl,
    currentDomain,
    isLoading,
    isRefreshing,
    trustScore,
    scoreExplanations,
    fetchData,
  } = useAnalysisData();

  const handleRefresh = () => {
    console.log("[Popup] Manual refresh triggered.");
    fetchData(true, true);
  };

  let content;
  const showInitialLoader =
    isLoading && !isRefreshing && !storedData?.analysis && !storedData?.error;
  const showErrorDisplay =
    storedData?.error &&
    (!trustScore || scoreExplanations.length === 0) &&
    !isRefreshing &&
    !isLoading;

  if (showInitialLoader) {
    content = <LoadingIndicator message="Inicjalizacja analizy..." />;
  } else if (showErrorDisplay) {
    content = (
      <ErrorDisplay
        error={storedData!.error!}
        onRetry={handleRefresh}
        isRetrying={isRefreshing}
      />
    );
  } else if (
    trustScore !== null ||
    scoreExplanations.length > 0 ||
    isRefreshing ||
    isLoading
  ) {
    content = (
      <>
        <ScoreDisplay
          score={trustScore}
          isLoading={isLoading || isRefreshing}
          errorOccurred={!!storedData?.error && !isLoading && !isRefreshing} // Pokaż błąd tylko jeśli nie ładujemy
          currentDomain={currentDomain}
          currentUrl={currentUrl}
        />
        <ScoreExplanationsList
          explanations={scoreExplanations}
          isLoading={isLoading || isRefreshing} // Przekaż oba stany
          errorOccurred={!!storedData?.error && !isLoading && !isRefreshing}
        />
        <Button
          onClick={handleRefresh}
          variant="secondary"
          size="sm"
          className="w-full mt-auto"
          disabled={isRefreshing || isLoading}
        >
          {isRefreshing || (isLoading && !trustScore && !storedData?.error) ? (
            <Loader2 className="mr-2 h-4 w-4 animate-spin" />
          ) : (
            <RefreshCw className="mr-2 h-4 w-4" />
          )}
          {isRefreshing ? "Odświeżanie..." : "Odśwież (z analizą treści)"}
        </Button>
      </>
    );
  } else {
    content = (
      <div className="flex flex-col items-center justify-center h-full py-4">
        <Info className="mx-auto mb-2 h-10 w-10 text-blue-500" />
        <p className="mb-4 text-sm text-gray-600 text-center px-2">
          {!currentDomain
            ? "Otwórz stronę http/https, aby rozpocząć analizę."
            : "Kliknij, aby przeanalizować tę stronę."}
        </p>
        <Button
          onClick={handleRefresh}
          variant="default"
          size="sm"
          disabled={isRefreshing || isLoading || !currentDomain}
        >
          {isLoading || isRefreshing ? (
            <Loader2 className="mr-2 h-4 w-4 animate-spin" />
          ) : (
            <RefreshCw className="mr-2 h-4 w-4" />
          )}
          Analizuj {currentDomain || ""}
        </Button>
      </div>
    );
  }

  return (
    <div className="w-96 rounded-md bg-white p-4 shadow-xl flex flex-col max-h-[580px] min-h-[450px]">
      <Header />
      <div className="flex-grow overflow-hidden flex flex-col">{content}</div>
      <Footer />
    </div>
  );
};

--------------------
File: C:\Users\zieba\Desktop\stuff\IsThisPhishy-addon\src\popup\popup.tsx
--------------------
import React from "react";
import ReactDOM from "react-dom/client";

import "../styles/globals.css";

import { PopupContent } from "./popup-content";

ReactDOM.createRoot(document.getElementById("root") as HTMLElement).render(
  <React.StrictMode>
    <PopupContent></PopupContent>
  </React.StrictMode>,
);

--------------------
File: C:\Users\zieba\Desktop\stuff\IsThisPhishy-addon\src\popup\components\ErrorDisplay.tsx
--------------------
// src/popup/components/ErrorDisplay.tsx
import React from "react";
import { FileWarning, RefreshCw, Loader2 } from "lucide-react";
import { Button } from "@/components/ui/button";

interface ErrorDisplayProps {
  error: string;
  onRetry: () => void;
  isRetrying: boolean;
}

export const ErrorDisplay: React.FC<ErrorDisplayProps> = ({
  error,
  onRetry,
  isRetrying,
}) => (
  <div className="flex flex-col items-center justify-center h-full py-4">
    <FileWarning className="mb-2 h-10 w-10 text-red-500" />
    <p className="mb-1 text-base font-semibold text-gray-800">Błąd Analizy</p>
    <p className="mb-4 text-xs text-gray-600 px-2 text-center">{error}</p>
    <Button onClick={onRetry} variant="outline" size="sm" disabled={isRetrying}>
      {isRetrying ? (
        <Loader2 className="mr-2 h-4 w-4 animate-spin" />
      ) : (
        <RefreshCw className="mr-2 h-4 w-4" />
      )}
      Spróbuj Ponownie
    </Button>
  </div>
);

--------------------
File: C:\Users\zieba\Desktop\stuff\IsThisPhishy-addon\src\popup\components\Header.tsx
--------------------
// src/popup/components/Header.tsx
import React from "react";
import { ExternalLink } from "lucide-react";

export const Header: React.FC = () => (
  <div className="mb-3 flex items-center justify-between">
    <div className="flex items-center">
      <img src="/icon.png" width={28} height={28} alt="Logo" className="mr-2" />
      <h1 className="text-lg font-bold text-gray-800">IsThisPhishy?</h1>
    </div>
  </div>
);

export const Footer: React.FC = () => (
  <div className="mt-auto pt-2 border-t border-gray-200 text-center">
    <a
      href="https://github.com/ziebamikolaj/IsThisPhishy-addon"
      target="_blank"
      rel="noopener noreferrer"
      className="text-xs text-blue-600 hover:underline hover:text-blue-800"
    >
      O projekcie <ExternalLink className="ml-1 h-3 w-3 inline-block" />
    </a>
  </div>
);

--------------------
File: C:\Users\zieba\Desktop\stuff\IsThisPhishy-addon\src\popup\components\InfoRow.tsx
--------------------
// src/popup/components/InfoRow.tsx
import React from "react";
import { ChevronDown, ChevronUp } from "lucide-react";
import {
  Tooltip,
  TooltipContent,
  TooltipProvider,
  TooltipTrigger,
} from "@/components/ui/tooltip";
import { ScoreExplanation } from "../services/scoreCalculator"; // Załóżmy, że typ jest tam

interface InfoRowProps extends ScoreExplanation {
  isExpanded?: boolean;
  onToggle?: () => void;
}

export const InfoRow: React.FC<InfoRowProps> = ({
  icon: Icon,
  label,
  valueText,
  impact,
  details,
  longDesc,
  scoreEffect,
  isExpanded,
  onToggle,
}) => {
  const getIconColor = () => {
    switch (impact) {
      case "positive":
        return "text-green-500";
      case "negative":
        return "text-red-500";
      case "info":
        return "text-blue-500";
      default:
        return "text-gray-500";
    }
  };

  return (
    <TooltipProvider delayDuration={300}>
      <div className="mb-1 border-b border-gray-200 last:border-b-0 py-2">
        <Tooltip>
          <TooltipTrigger asChild>
            <div
              className="flex items-center justify-between text-sm cursor-pointer"
              onClick={longDesc && onToggle ? onToggle : undefined}
              onKeyDown={
                longDesc && onToggle
                  ? (e) => (e.key === "Enter" || e.key === " ") && onToggle()
                  : undefined
              }
              role={longDesc ? "button" : undefined}
              tabIndex={longDesc ? 0 : undefined}
              aria-expanded={longDesc ? isExpanded : undefined}
              aria-controls={
                longDesc
                  ? `desc-${label.replace(/\s+/g, "-").toLowerCase()}`
                  : undefined
              }
            >
              <div className="flex items-center min-w-0">
                {" "}
                {/* min-w-0 dla truncate */}
                <Icon className={`mr-2 h-5 w-5 shrink-0 ${getIconColor()}`} />
                <span className="font-medium truncate" title={label}>
                  {label}:
                </span>{" "}
                {/* truncate */}
              </div>
              <div className="flex items-center ml-2 shrink-0">
                {" "}
                {/* shrink-0 zapobiega rozpychaniu */}
                <span className="text-right break-words">{valueText}</span>{" "}
                {/* break-words dla długich wartości */}
                {longDesc &&
                  (isExpanded ? (
                    <ChevronUp className="ml-1 h-4 w-4 text-gray-500" />
                  ) : (
                    <ChevronDown className="ml-1 h-4 w-4 text-gray-500" />
                  ))}
              </div>
            </div>
          </TooltipTrigger>
          <TooltipContent
            side="top"
            className="max-w-xs text-center bg-gray-800 text-white rounded-md p-2 shadow-lg"
          >
            <p>{details}</p>
            {scoreEffect && (
              <p className="text-xs italic mt-1">({scoreEffect})</p>
            )}
          </TooltipContent>
        </Tooltip>
        {longDesc && isExpanded && (
          <div
            id={`desc-${label.replace(/\s+/g, "-").toLowerCase()}`}
            className="mt-2 pl-7 text-xs text-gray-600 bg-gray-50 p-2 rounded prose prose-sm max-w-full overflow-x-auto"
          >
            {typeof longDesc === "string" ? <p>{longDesc}</p> : longDesc}
          </div>
        )}
      </div>
    </TooltipProvider>
  );
};

--------------------
File: C:\Users\zieba\Desktop\stuff\IsThisPhishy-addon\src\popup\components\LoadingIndicator.tsx
--------------------
// src/popup/components/LoadingIndicator.tsx
import React from "react";
import { Loader2 } from "lucide-react";

interface LoadingIndicatorProps {
  message?: string;
}

export const LoadingIndicator: React.FC<LoadingIndicatorProps> = ({
  message = "Ładowanie danych...",
}) => (
  <div className="flex flex-col items-center justify-center h-full py-8">
    <Loader2 className="mb-4 h-10 w-10 animate-spin text-blue-600" />
    <p className="text-sm text-gray-600">{message}</p>
  </div>
);

--------------------
File: C:\Users\zieba\Desktop\stuff\IsThisPhishy-addon\src\popup\components\ScoreDisplay.tsx
--------------------
// src/popup/components/ScoreDisplay.tsx
import React from "react";
import { Loader2 } from "lucide-react";

interface ScoreDisplayProps {
  score: number | null;
  isLoading: boolean; // Czy główny wynik jest ładowany
  errorOccurred?: boolean;
  currentDomain: string;
  currentUrl: string;
}

export const ScoreDisplay: React.FC<ScoreDisplayProps> = ({
  score,
  isLoading,
  errorOccurred,
  currentDomain,
  currentUrl,
}) => {
  const getScoreColorClasses = (
    s: number | null
  ): { bg: string; text: string; ring: string } => {
    if (s === null)
      return {
        bg: "bg-gray-400",
        text: "text-gray-700",
        ring: "ring-gray-400",
      };
    if (s < 40)
      return { bg: "bg-red-500", text: "text-white", ring: "ring-red-500" };
    if (s < 70)
      return {
        bg: "bg-yellow-500",
        text: "text-black",
        ring: "ring-yellow-500",
      };
    return { bg: "bg-green-500", text: "text-white", ring: "ring-green-500" };
  };

  const getScoreTextDescription = (
    s: number | null,
    loading: boolean,
    error: boolean | undefined
  ): string => {
    if (loading && s === null && !error) return "Analizowanie...";
    if (error && s === null) return "Błąd Oceny";
    if (s === null && !loading) return "Brak Oceny";
    if (s === null) return "Analizowanie..."; // Fallback
    if (s < 40) return "Wysokie Ryzyko";
    if (s < 70) return "Podwyższone Ryzyko";
    return "Niskie Ryzyko";
  };

  const colorClasses = getScoreColorClasses(score);
  const scoreText = getScoreTextDescription(score, isLoading, errorOccurred);

  return (
    <div className="mb-4 text-center">
      <div
        className={`mx-auto mb-3 h-20 w-20 rounded-full ring-4 ${colorClasses.ring} ${colorClasses.bg} flex items-center justify-center`}
      >
        <span className={`text-3xl font-bold ${colorClasses.text}`}>
          {isLoading && score === null && !errorOccurred ? (
            <Loader2 className="h-8 w-8 animate-spin" />
          ) : (
            score ?? "?"
          )}
        </span>
      </div>
      <p
        className={`text-lg font-semibold ${colorClasses.text
          .replace("text-white", "text-gray-800")
          .replace("text-black", "text-gray-800")
          .replace("text-gray-700", "text-gray-600")}`}
      >
        {" "}
        {/* Użyj ciemniejszego tekstu dla opisu */}
        {scoreText}
      </p>
      <p
        className="text-xs text-gray-500 mt-1 truncate px-2"
        title={currentUrl}
      >
        Analiza dla:{" "}
        <span className="font-medium">{currentDomain || "Bieżąca strona"}</span>
      </p>
    </div>
  );
};

--------------------
File: C:\Users\zieba\Desktop\stuff\IsThisPhishy-addon\src\popup\components\ScoreExplanations.tsx
--------------------
// src/popup/components/ScoreExplanations.tsx
import React, { useState } from "react";
import { Loader2 } from "lucide-react";
import { InfoRow } from "./InfoRow"; // Zakładając, że jest w tym samym folderze
import { ScoreExplanation } from "../services/scoreCalculator";

interface ScoreExplanationsProps {
  explanations: ScoreExplanation[];
  isLoading: boolean; // Czy wskaźniki są ładowane
  errorOccurred?: boolean;
}

export const ScoreExplanationsList: React.FC<ScoreExplanationsProps> = ({
  explanations,
  isLoading,
  errorOccurred,
}) => {
  const [expandedRow, setExpandedRow] = useState<string | null>(null);
  const toggleRowExpansion = (id: string) =>
    setExpandedRow(expandedRow === id ? null : id);

  if (isLoading && explanations.length === 0 && !errorOccurred) {
    return (
      <div className="text-center py-4">
        <Loader2 className="mx-auto h-6 w-6 animate-spin text-gray-400" />
        <p className="text-xs text-gray-500 mt-1">Ładowanie wskaźników...</p>
      </div>
    );
  }

  if (explanations.length === 0 && !isLoading && !errorOccurred) {
    return (
      <p className="text-xs text-gray-500 text-center py-4">
        Brak szczegółowych wskaźników do wyświetlenia.
      </p>
    );
  }
  if (explanations.length === 0 && errorOccurred) {
    return null; // Nie pokazuj nic, jeśli jest globalny błąd
  }

  return (
    <div className="mb-3 flex-grow overflow-y-auto pr-1 custom-scrollbar">
      {" "}
      {/* custom-scrollbar jeśli masz definicję */}
      <h3 className="text-sm font-semibold text-gray-700 mb-2 sticky top-0 bg-white py-1 z-10 border-b">
        Kluczowe Wskaźniki:
      </h3>
      {explanations.map((exp) => (
        <InfoRow
          key={exp.id}
          {...exp}
          isExpanded={expandedRow === exp.id}
          onToggle={() => toggleRowExpansion(exp.id)}
        />
      ))}
    </div>
  );
};

--------------------
File: C:\Users\zieba\Desktop\stuff\IsThisPhishy-addon\src\popup\consts\scorePoints.ts
--------------------
export const PTS = {
  age: { y: -10, vy: -20, m: 10, vm: 20, unknown: -2 },
  ssl: { v: 10, e: -18, p: -18, h: -22, es: -4, unknown: -5 },
  bl: { l: -30, c: 6, multiple: -10 },
  ipInUrl: -15,
  urlAi: {
    ph90: -5,
    ph70: -3,
    ph50: -1,
    lh90: 5,
    lh70: 3,
    error: -2,
    neutral: 0,
  },
  contentAi: {
    phChunkHighConf: -8,
    phChunkMedConf: -4,
    phChunkLowConf: -2,
    manyPhishingChunksPenalty: -10,
    noProblemDetected: 5,
    noContentOrError: -1,
  },
  whoisPrivacy: { enabled: -2, explicitProblem: -5 },
  dnsMx: { missingForShop: -5, presentForShop: 2, notApplicable: 0 },
};

--------------------
File: C:\Users\zieba\Desktop\stuff\IsThisPhishy-addon\src\popup\hooks\useAnalysisData.ts
--------------------
// src/popup/hooks/useAnalysisData.ts
import { useState, useEffect, useCallback } from "react";
import { StoredDomainData } from "@/types/domainAnalysis";
import {
  calculateTrustScore,
  ScoreExplanation,
} from "../services/scoreCalculator";
import { getDomainFromUrl as getDomainFromUrlHelper } from "../utils/helpers";

export function useAnalysisData() {
  const [storedData, setStoredData] = useState<StoredDomainData | null>(null);
  const [currentUrl, setCurrentUrl] = useState<string>("");
  const [currentDomain, setCurrentDomain] = useState<string>("");
  const [currentTabId, setCurrentTabId] = useState<number | undefined>();
  const [isLoading, setIsLoading] = useState(true);
  const [isRefreshing, setIsRefreshing] = useState(false);
  const [trustScore, setTrustScore] = useState<number | null>(null);
  const [scoreExplanations, setScoreExplanations] = useState<
    ScoreExplanation[]
  >([]);

  const processData = useCallback(
    (data: StoredDomainData | null, urlForAnalysis: string) => {
      console.log(
        "[Hook] processData called with data for URL:",
        urlForAnalysis,
        data
      );
      setStoredData(data);
      if (data?.error && (!data.analysis || !data.urlTextAnalysis)) {
        console.warn("[Hook] Error in received data:", data.error);
        setTrustScore(null);
        setScoreExplanations([]);
      } else if (data?.analysis) {
        const { score, explanations } = calculateTrustScore(
          data,
          urlForAnalysis
        );
        setTrustScore(score);
        setScoreExplanations(explanations);
      } else {
        setTrustScore(null);
        setScoreExplanations([]);
      }
    },
    [] // This function is now fully stable
  );

  const fetchData = useCallback(
    (forceRefresh = false, forceContentFetch = false) => {
      if (!currentUrl) {
        console.warn("[Hook] fetchData: No currentUrl to analyze.");
        setIsLoading(false);
        setIsRefreshing(false);
        processData(
          { error: "Brak aktywnego URL.", lastChecked: Date.now() },
          ""
        );
        return;
      }

      console.log(
        `[Hook] fetchData triggered. forceRefresh: ${forceRefresh}, forceContent: ${forceContentFetch}, URL: ${currentUrl}`
      );

      if (forceRefresh) setIsRefreshing(true);
      else setIsLoading(true);

      // The background script will handle the badge update.
      chrome.runtime.sendMessage(
        {
          action: "requestAnalysisForCurrentTab",
          forceContentRefresh: forceContentFetch || forceRefresh,
          forDomain: currentDomain,
          url: currentUrl,
          tabId: currentTabId,
        },
        (response) => {
          console.log(
            "[Hook] fetchData response from background:",
            response,
            "For URL:",
            currentUrl
          );
          let needsReset = true;

          if (chrome.runtime.lastError) {
            console.error(
              "[Hook] fetchData sendMessage error:",
              chrome.runtime.lastError.message
            );
            processData(
              { error: "Błąd komunikacji z tłem.", lastChecked: Date.now() },
              currentUrl
            );
          } else if (
            response?.status?.includes("triggered") ||
            response?.status?.includes("processing")
          ) {
            console.log(
              "[Hook] Background is processing, will wait for 'analysisUpdated'."
            );
            needsReset = false;
          } else if (response?.error) {
            processData(response as StoredDomainData, currentUrl);
          } else if (response) {
            processData(response as StoredDomainData, currentUrl);
          } else {
            processData(
              {
                error: "Nieoczekiwana odpowiedź od tła.",
                lastChecked: Date.now(),
              },
              currentUrl
            );
          }

          if (needsReset) {
            if (forceRefresh) setIsRefreshing(false);
            else setIsLoading(false);
          }
        }
      );
    },
    [currentUrl, currentDomain, processData, currentTabId]
  );

  useEffect(() => {
    console.log(
      "[Hook] Initializing: attaching listeners, getting active tab."
    );
    setIsLoading(true);

    chrome.tabs.query({ active: true, currentWindow: true }, (tabs) => {
      const activeTab = tabs[0];
      if (activeTab?.url && activeTab.url.startsWith("http")) {
        const newUrl = activeTab.url;
        const newDomain = getDomainFromUrlHelper(newUrl);
        console.log(
          `[Hook] Initial active tab: ${newUrl} (Domain: ${newDomain})`
        );
        setCurrentUrl(newUrl);
        setCurrentDomain(newDomain);
        setCurrentTabId(activeTab.id);
      } else {
        console.warn("[Hook] No valid active tab URL for initialization.");
        setCurrentUrl("");
        setCurrentDomain("");
        setCurrentTabId(activeTab.id);
        processData(
          {
            error: "Brak aktywnej strony http/https.",
            lastChecked: Date.now(),
          },
          ""
        );
        setIsLoading(false);
      }
    });
  }, [processData]);

  useEffect(() => {
    if (currentUrl && currentDomain && isLoading) {
      console.log(
        `[Hook] URL/Domain set (${currentUrl}). Checking cache or fetching.`
      );
      chrome.storage.local.get(currentDomain, (result) => {
        const cachedData: StoredDomainData | undefined = result[currentDomain];
        const fiveMinutes = 5 * 60 * 1000;
        if (
          cachedData?.analysis &&
          Date.now() - cachedData.lastChecked < fiveMinutes &&
          !cachedData.error
        ) {
          console.log(
            "[Hook] Using cached data for",
            currentDomain,
            cachedData
          );
          processData(cachedData, currentUrl);
          setIsLoading(false);
        } else {
          console.log(
            "[Hook] Cache miss or invalid for",
            currentDomain,
            ". Fetching fresh data with content."
          );
          fetchData(false, true);
        }
      });
    } else if (!currentUrl && isLoading) {
      setIsLoading(false);
      processData(
        {
          error: "Nie można ustalić adresu URL aktywnej karty.",
          lastChecked: Date.now(),
        },
        ""
      );
    }
  }, [currentUrl, currentDomain, isLoading, fetchData, processData]);

  useEffect(() => {
    console.log("[Hook] Attaching message listener.");
    const messageListener = (message: {
      action: string;
      domain?: string;
      data?: StoredDomainData;
    }) => {
      console.log("[Hook] Message received from background:", message);
      if (
        message.action === "analysisUpdated" &&
        message.data &&
        message.domain
      ) {
        if (message.domain === currentDomain) {
          console.log(
            "[Hook] 'analysisUpdated' for current domain:",
            message.domain,
            "Applying data."
          );
          processData(message.data, currentUrl);
          setIsLoading(false);
          setIsRefreshing(false);
        } else {
          console.log(
            `[Hook] 'analysisUpdated' for domain ${message.domain}, but current is ${currentDomain}. Ignoring.`
          );
        }
      }
    };
    chrome.runtime.onMessage.addListener(messageListener);
    return () => {
      console.log("[Hook] Cleaning up message listener.");
      chrome.runtime.onMessage.removeListener(messageListener);
    };
  }, [currentDomain, currentUrl, processData]);

  return {
    storedData,
    currentUrl,
    currentDomain,
    isLoading,
    isRefreshing,
    trustScore,
    scoreExplanations,
    fetchData,
  };
}

--------------------
File: C:\Users\zieba\Desktop\stuff\IsThisPhishy-addon\src\popup\services\scoreCalculator.tsx
--------------------
// src/popup/services/scoreCalculator.tsx

import { StoredDomainData } from "@/types/domainAnalysis";
import {
  ShieldQuestion,
  CalendarDays,
  Lock,
  ShieldAlert,
  ShieldCheck,
  Network,
  MessageSquareQuote,
  Mail,
} from "lucide-react";

// Simple formatDomainAge implementation
const formatDomainAge = (days: number): string => {
  if (days < 30) return `${days} dni`;
  if (days < 365) return `${Math.floor(days / 30)} mies.`;
  return `${Math.floor(days / 365)} lat`;
};

export type ExplanationImpact = "positive" | "negative" | "neutral" | "info";
export interface ScoreExplanation {
  id: string;
  icon: React.ElementType;
  label: string;
  valueText: string | React.ReactNode;
  impact: ExplanationImpact;
  details: string;
  longDesc?: string | React.ReactNode;
  scoreEffect?: string;
}

import { PTS } from "../consts/scorePoints";

export function calculateTrustScore(
  fullData: StoredDomainData | null | undefined,
  currentUrl: string
): { score: number | null; explanations: ScoreExplanation[] } {
  if (!fullData?.analysis) {
    console.warn(
      "[ScoreCalc] No analysis data provided for score calculation."
    );
    return { score: null, explanations: [] };
  }

  const analysisData = fullData.analysis;
  const urlAiAnalysis = fullData.urlTextAnalysis;
  const contentAiAnalyses = fullData.pageContentAnalyses;

  let score = 50;
  const explanations: ScoreExplanation[] = [];
  const MAX = 100,
    MIN = 0;

  console.log(
    "[ScoreCalc] Starting calculation. Initial score:",
    score,
    "for URL:",
    currentUrl
  );
  console.log(
    "[ScoreCalc] DomainAnalysisDetails:",
    JSON.parse(JSON.stringify(analysisData))
  );
  console.log(
    "[ScoreCalc] UrlTextAnalysis:",
    JSON.parse(JSON.stringify(urlAiAnalysis || {}))
  );
  console.log(
    "[ScoreCalc] PageContentAnalyses:",
    JSON.parse(JSON.stringify(contentAiAnalyses || []))
  );

  // Domain Age
  const ageD = analysisData.domain_actual_age_days;
  let ageI: ExplanationImpact = "neutral",
    ageSE = "0 pkt";
  let ageVT: string | React.ReactNode = "N/A";
  if (ageD !== null && typeof ageD !== "undefined") {
    ageVT = formatDomainAge(ageD);
    if (ageD < 30) {
      score += PTS.age.vy;
      ageI = "negative";
      ageSE = `${PTS.age.vy} pkt`;
    } else if (ageD < 180) {
      score += PTS.age.y;
      ageI = "negative";
      ageSE = `${PTS.age.y} pkt`;
    } else if (ageD >= 730) {
      score += PTS.age.vm;
      ageI = "positive";
      ageSE = `+${PTS.age.vm} pkt`;
    } else if (ageD >= 365) {
      score += PTS.age.m;
      ageI = "positive";
      ageSE = `+${PTS.age.m} pkt`;
    }
  } else {
    score += PTS.age.unknown;
    ageI = "info";
    ageSE = `${PTS.age.unknown} pkt (brak danych)`;
  }
  explanations.push({
    id: "age",
    icon: CalendarDays,
    label: "Wiek domeny",
    valueText: ageVT,
    impact: ageI,
    scoreEffect: ageSE,
    details: "Starsze domeny są generalnie bardziej wiarygodne.",
    longDesc:
      "Nowo zarejestrowane domeny są często wykorzystywane w kampaniach phishingowych...",
  });

  // SSL
  let sslI: ExplanationImpact = "negative",
    sslDet = "Strona nie używa szyfrowania HTTPS.",
    sslVT: string | React.ReactNode = "Brak (HTTP)";
  let tempSslSE = PTS.ssl.h;
  if (analysisData.parsed_url_scheme === "https") {
    tempSslSE = 0;
    if (analysisData.ssl_info && analysisData.ssl_info.not_after) {
      const expD = new Date(analysisData.ssl_info.not_after);
      const now = new Date();
      const dToExp = (expD.getTime() - now.getTime()) / (1000 * 3600 * 24);
      if (dToExp > 0) {
        tempSslSE = PTS.ssl.v;
        sslI = "positive";
        sslVT = "Ważny";
        sslDet = `Połączenie szyfrowane. Certyfikat ważny do: ${expD.toLocaleDateString()}.`;
        if (dToExp < 30) {
          tempSslSE += PTS.ssl.es;
          sslVT = (
            <span className="text-yellow-600 font-semibold">
              Wygasa wkrótce!
            </span>
          );
          sslDet += " Certyfikat wygasa za mniej niż 30 dni.";
        }
      } else {
        tempSslSE = PTS.ssl.e;
        sslI = "negative";
        sslVT = "Wygasł";
        sslDet = `Certyfikat SSL wygasł: ${expD.toLocaleDateString()}.`;
      }
    } else {
      tempSslSE = PTS.ssl.p;
      sslI = "negative";
      sslVT = "Problem (HTTPS)";
      sslDet =
        "Strona używa HTTPS, ale wystąpił problem z weryfikacją certyfikatu...";
    }
  } else if (
    analysisData.ssl_info === null &&
    analysisData.parsed_url_scheme !== "https"
  ) {
    sslI = "negative";
    sslVT = "Brak (HTTP)";
    sslDet = "Strona nie używa szyfrowania HTTPS (HTTP).";
  } else {
    tempSslSE = PTS.ssl.unknown;
    sslI = "info";
    sslVT = "N/A (SSL)";
    sslDet = "Nie udało się jednoznacznie zweryfikować statusu SSL.";
  }
  score += tempSslSE;
  const sslSETxt = `${tempSslSE > 0 ? "+" : ""}${tempSslSE} pkt`;
  explanations.push({
    id: "ssl",
    icon: Lock,
    label: "Szyfrowanie (SSL)",
    valueText: sslVT,
    impact: sslI,
    details: sslDet,
    scoreEffect: sslSETxt,
    longDesc:
      "Certyfikat SSL zapewnia szyfrowanie danych przesyłanych między Tobą a stroną...",
  });

  // URL AI Analysis
  let urlAiSEV = 0;
  let urlAiVT: string | React.ReactNode = "Niedostępna";
  let urlAiI: ExplanationImpact = "neutral";
  let urlAiDet =
    "Analiza AI adresu URL nie została przeprowadzona lub jest niedostępna.";

  if (urlAiAnalysis === null) {
    urlAiSEV = PTS.urlAi.error;
    urlAiVT = <span className="text-red-500">Błąd analizy</span>;
    urlAiI = "negative";
    urlAiDet =
      "Nie udało się przeprowadzić analizy AI dla tego URL z powodu błędu.";
  } else if (urlAiAnalysis) {
    urlAiVT = `${urlAiAnalysis.label} (${(
      urlAiAnalysis.confidence * 100
    ).toFixed(0)}%)`;
    urlAiDet = `Model AI ocenił URL jako ${urlAiAnalysis.label.toLowerCase()} z ${(
      urlAiAnalysis.confidence * 100
    ).toFixed(0)}% pewnością.`;
    if (urlAiAnalysis.is_phishing) {
      urlAiI = "negative";
      if (urlAiAnalysis.confidence >= 0.9) urlAiSEV = PTS.urlAi.ph90;
      else if (urlAiAnalysis.confidence >= 0.7) urlAiSEV = PTS.urlAi.ph70;
      else urlAiSEV = PTS.urlAi.ph50;
    } else {
      urlAiI = urlAiAnalysis.confidence >= 0.9 ? "positive" : "neutral";
      urlAiSEV =
        urlAiAnalysis.confidence >= 0.9
          ? PTS.urlAi.lh90
          : urlAiAnalysis.confidence >= 0.7
          ? PTS.urlAi.lh70
          : PTS.urlAi.neutral;
    }
  } else {
    urlAiVT = <span className="text-gray-500">N/A (URL AI)</span>;
    urlAiI = "neutral";
    urlAiDet =
      "Analiza AI adresu URL nie została jeszcze przeprowadzona lub dane nie są dostępne.";
  }
  explanations.push({
    id: "aiUrl",
    icon: ShieldQuestion,
    label: "Analiza AI URL",
    valueText: urlAiVT,
    impact: urlAiI,
    scoreEffect: `${urlAiSEV > 0 ? "+" : ""}${urlAiSEV} pkt`,
    details: urlAiDet,
    longDesc:
      "Sztuczna inteligencja analizuje strukturę i komponenty adresu URL...",
  });
  score += urlAiSEV;

  // Content AI Analysis
  let cAiVT: string | React.ReactNode = "N/A";
  let cAiI: ExplanationImpact = "neutral",
    cAiSEV = 0;
  let cAiDet =
    "Analiza treści strony nie została przeprowadzona lub brakło tekstu.";
  let cAiLDReactNode: React.ReactNode =
    "Analiza treści strony wyszukuje fragmenty mogące wskazywać na oszustwo...";
  const sChunksI: { label: string; conf: number; chunk: string }[] = [];

  if (contentAiAnalyses === null) {
    cAiVT = <span className="text-red-500">Błąd analizy treści</span>;
    cAiI = "negative";
    cAiSEV = PTS.contentAi.noContentOrError;
    cAiDet = "Wystąpił błąd podczas próby analizy treści strony.";
  } else if (contentAiAnalyses && contentAiAnalyses.length > 0) {
    let pC = 0,
      hCP = false,
      mCP = false,
      lCP = false;
    contentAiAnalyses.forEach((ca) => {
      if (ca.is_phishing) {
        pC++;
        if (ca.confidence >= 0.9) hCP = true;
        else if (ca.confidence >= 0.7) mCP = true;
        else if (ca.confidence >= 0.5) lCP = true;
        sChunksI.push({
          label: ca.label,
          conf: ca.confidence,
          chunk: ca.originalChunk,
        });
      }
    });

    if (pC > 0) {
      // Calculate penalty only if phishing chunks are found
      if (hCP) {
        cAiSEV = PTS.contentAi.phChunkHighConf;
        cAiI = "negative";
        cAiVT = (
          <span className="text-red-500 font-semibold">Podejrzane Treści!</span>
        );
        cAiDet = `Wykryto fragmenty treści o wysokim prawdopodobieństwie phishingu (${pC}/${contentAiAnalyses.length}).`;
      } else if (mCP) {
        cAiSEV = PTS.contentAi.phChunkMedConf;
        cAiI = "negative";
        cAiVT = "Podejrzane fragmenty";
        cAiDet = `Wykryto ${pC} z ${contentAiAnalyses.length} fragmentów jako potencjalnie phishingowe.`;
      } else if (lCP) {
        cAiSEV = PTS.contentAi.phChunkLowConf;
        cAiI = "negative";
        cAiVT = "Niejednoznaczne fragmenty";
        cAiDet = `Wykryto ${pC} z ${contentAiAnalyses.length} fragmentów jako potencjalnie phishingowe.`;
      }

      if (pC >= 3) {
        cAiSEV += PTS.contentAi.manyPhishingChunksPenalty;
        cAiDet += " Znaleziono wiele podejrzanych fragmentów.";
      }

      // <<< THIS IS THE FIX >>>
      // Cap the total penalty at -10 to prevent it from being too harsh.
      cAiSEV = Math.max(cAiSEV, -10);
    } else {
      // No phishing chunks were found
      cAiSEV = PTS.contentAi.noProblemDetected;
      cAiI = "positive";
      cAiVT = "Treść OK";
      cAiDet = `Analiza treści (${contentAiAnalyses.length} fragmentów) nie wykazała znamion phishingu.`;
    }

    if (sChunksI.length > 0) {
      const listItems = sChunksI.slice(0, 3).map((s, i) => (
        <li
          key={`chunk-${i}-${s.chunk.slice(0, 5)}`}
          title={s.chunk}
          className="mb-1"
        >
          <span
            className={`font-semibold ${
              s.label === "PHISHING" ? "text-red-600" : "text-gray-700"
            }`}
          >
            "{s.chunk.substring(0, 50)}..."
          </span>
          <span className="text-gray-500 ml-1">
            ({s.label} {(s.conf * 100).toFixed(0)}%)
          </span>
        </li>
      ));
      cAiLDReactNode = (
        <div>
          <p>
            {typeof cAiLDReactNode === "string"
              ? cAiLDReactNode
              : "Szczegóły analizy treści:"}
          </p>
          <p className="mt-2 font-semibold">Podejrzane fragmenty:</p>
          <ul className="list-disc pl-5 max-h-24 overflow-y-auto text-xs custom-scrollbar">
            {listItems}
          </ul>
          {sChunksI.length > 3 && (
            <p className="text-xs mt-1">...i {sChunksI.length - 3} więcej.</p>
          )}
        </div>
      );
    }
  } else if (contentAiAnalyses && contentAiAnalyses.length === 0) {
    cAiSEV = PTS.contentAi.noContentOrError;
    cAiI = "info";
    cAiVT = "Brak tekstu do analizy";
    cAiDet =
      "Nie znaleziono wystarczającej ilości tekstu na stronie do przeprowadzenia pełnej analizy treści.";
  } else {
    cAiVT = <span className="text-gray-500">N/A (treść)</span>;
    cAiI = "neutral";
    cAiDet =
      "Analiza treści strony nie została jeszcze przeprowadzona lub dane nie są dostępne.";
  }
  score += cAiSEV;
  explanations.push({
    id: "contentAi",
    icon: MessageSquareQuote,
    label: "Analiza AI treści",
    valueText: cAiVT,
    impact: cAiI,
    scoreEffect: `${cAiSEV > 0 ? "+" : ""}${cAiSEV} pkt`,
    details: cAiDet,
    longDesc: cAiLDReactNode,
  });

  // Blacklist
  let blSEV = 0;
  const listedSources: string[] = [];
  if (analysisData.blacklist_checks) {
    analysisData.blacklist_checks.forEach((c) => {
      if (c.is_listed) {
        listedSources.push(c.source);
      }
    });
  }
  if (listedSources.length > 0) {
    blSEV = PTS.bl.l; // Base penalty
    if (listedSources.length > 1) {
      blSEV += PTS.bl.multiple * (listedSources.length - 1); // Additional penalty
    }
    explanations.push({
      id: "blacklist",
      icon: ShieldAlert,
      label: "Listy zagrożeń",
      valueText: `Na listach: ${listedSources.join(", ")}`,
      impact: "negative",
      scoreEffect: `${blSEV} pkt`,
      details: `Znalezienie domeny/URL na publicznych listach zagrożeń (${listedSources.join(
        ", "
      )}) jest silnym sygnałem ostrzegawczym.`,
      longDesc:
        "Listy te są kompilowane przez organizacje bezpieczeństwa w celu śledzenia złośliwych witryn internetowych.",
    });
  } else {
    blSEV = PTS.bl.c;
    explanations.push({
      id: "blacklist",
      icon: ShieldCheck,
      label: "Listy zagrożeń",
      valueText: "Czysto",
      impact: "positive",
      scoreEffect: `+${blSEV} pkt`,
      details:
        "Nie znaleziono na znanych listach zagrożeń (m.in. PhishTank, CERT.PL, OpenPhish, Google Safe Browsing).",
      longDesc:
        "Brak wpisów na głównych listach zagrożeń to dobry znak, wskazujący, że strona nie została publicznie oznaczona jako złośliwa.",
    });
  }
  score += blSEV;

  // IP in URL
  let ipUrlSEV = 0;
  if (analysisData.is_ip_address_in_url) {
    ipUrlSEV = PTS.ipInUrl;
    explanations.push({
      id: "ipInUrl",
      icon: Network,
      label: "Adres IP w URL",
      valueText: "Tak",
      impact: "negative",
      scoreEffect: `${ipUrlSEV} pkt`,
      details:
        "Używanie adresu IP zamiast nazwy domenowej jest częstą taktyką w phishingu.",
      longDesc:
        "Legalne strony rzadko używają adresów IP bezpośrednio w linkach...",
    });
  } else {
    explanations.push({
      id: "ipInUrl",
      icon: Network,
      label: "Adres IP w URL",
      valueText: "Nie",
      impact: "positive",
      details: "URL używa standardowej nazwy domenowej.",
      scoreEffect: "+0 pkt",
    });
  }
  score += ipUrlSEV;

  // DNS MX Records
  let dnsMxSEV = 0;
  let dnsMxVT: string | React.ReactNode = "N/A";
  let dnsMxI: ExplanationImpact = "neutral";
  let dnsMxDet = "Brak danych o rekordach MX.";

  if (analysisData.dns_records && analysisData.dns_records.MX) {
    if (analysisData.dns_records.MX.length === 0) {
      dnsMxSEV = PTS.dnsMx.missingForShop;
      dnsMxVT = "Brak";
      dnsMxI = "negative";
      dnsMxDet = "Brak rekordów MX dla domeny.";
    } else {
      dnsMxSEV = PTS.dnsMx.presentForShop;
      dnsMxVT = "Obecne";
      dnsMxI = "positive";
      dnsMxDet = "Rekordy MX obecne dla domeny.";
    }
  } else {
    dnsMxSEV = PTS.dnsMx.notApplicable;
    dnsMxVT = "Nie dotyczy";
    dnsMxDet = "Brak danych o rekordach MX.";
  }
  score += dnsMxSEV;
  explanations.push({
    id: "dnsMx",
    icon: Mail,
    label: "Rekordy MX",
    valueText: dnsMxVT,
    impact: dnsMxI,
    scoreEffect: `${dnsMxSEV > 0 ? "+" : ""}${dnsMxSEV} pkt`,
    details: dnsMxDet,
    longDesc: "Rekordy MX wskazują serwery pocztowe dla domeny...",
  });

  const finalScore = Math.max(MIN, Math.min(MAX, Math.round(score)));
  console.log(
    `[ScoreCalc] Final calculated score: ${finalScore} (raw score before clamp: ${score})`
  );
  return { score: finalScore, explanations };
}

--------------------
File: C:\Users\zieba\Desktop\stuff\IsThisPhishy-addon\src\popup\utils\helpers.ts
--------------------
// src/popup/utils/helpers.ts
export const formatDomainAge = (days: number | null | undefined): string => {
  if (days === null || typeof days === "undefined") return "N/A";
  if (days < 0) return "Data przyszła (podejrzane)";
  if (days < 30) return `${days} dni (bardzo młoda)`;
  if (days < 180) return `${Math.floor(days / 30)} mies. (młoda)`;
  if (days < 365) return `${Math.floor(days / 30)} mies. (poniżej roku)`;
  const y = Math.floor(days / 365);
  const m = Math.floor((days % 365) / 30);
  return `${y} ${y === 1 ? "r." : "l."}${m > 0 ? ` i ${m}m.` : ""} (dojrzała)`;
};

export const getDomainFromUrl = (url: string): string => {
  try {
    const u = new URL(url);
    return u.hostname.replace(/^www\./, "");
  } catch {
    return "";
  }
};

export const getScoreVisuals = (
  score: number | null,
  isLoading: boolean = false,
  errorOccurred: boolean = false
): {
  bgColor: string;
  textColor: string;
  ringColor: string;
  description: string;
  scoreText: string | React.ReactElement;
} => {
  let bgColor = "bg-gray-400";
  let textColor = "text-gray-700";
  let ringColor = "ring-gray-400";
  let description = "Analizowanie...";
  let scoreText: string | React.ReactElement = "?";

  if (isLoading && score === null && !errorOccurred) {
    description = "Analizowanie...";
    // scoreText pozostaje "?" lub można dać ikonę loadera, ale to w komponencie
  } else if (errorOccurred && score === null) {
    description = "Błąd Oceny";
    bgColor = "bg-red-500";
    textColor = "text-white";
    ringColor = "ring-red-500";
  } else if (score === null && !isLoading) {
    description = "Brak Oceny";
  } else if (score !== null) {
    scoreText = score.toString();
    if (score < 40) {
      bgColor = "bg-red-500";
      textColor = "text-white";
      ringColor = "ring-red-500";
      description = "Wysokie Ryzyko";
    } else if (score < 70) {
      bgColor = "bg-yellow-500";
      textColor = "text-black";
      ringColor = "ring-yellow-500";
      description = "Podwyższone Ryzyko";
    } else {
      bgColor = "bg-green-500";
      textColor = "text-white";
      ringColor = "ring-green-500";
      description = "Niskie Ryzyko";
    }
  }

  return { bgColor, textColor, ringColor, description, scoreText };
};

--------------------
File: C:\Users\zieba\Desktop\stuff\IsThisPhishy-addon\src\styles\globals.css
--------------------
@tailwind base;
@tailwind components;
@tailwind utilities;

--------------------
File: C:\Users\zieba\Desktop\stuff\IsThisPhishy-addon\src\types\domainAnalysis.ts
--------------------
export interface SSLInfo {
  issuer: { [key: string]: string } | null;
  subject: { [key: string]: string } | null;
  version: number | null;
  serial_number: string | null;
  not_before: string | null;
  not_after: string | null;
}

export interface WhoisInfo {
  registrar: string | null;
  creation_date: string | null;
  expiration_date: string | null;
  updated_date: string | null;
  name_servers: string[] | null;
  emails: string[] | null;
  status: string[] | null;
}

export interface BlacklistCheckResult {
  source: string;
  is_listed: boolean;
  details: unknown | null;
}

export interface DomainAnalysisDetails {
  domain_name: string | null;
  parsed_url_scheme: string | null;
  parsed_url_path: string | null;
  parsed_url_query: string | null;
  dns_records: { [key: string]: string[] } | null;
  ssl_info: SSLInfo | null;
  whois_info: WhoisInfo | null;
  domain_actual_age_days: number | null;
  blacklist_checks: BlacklistCheckResult[] | null;
  is_ip_address_in_url: boolean;
  error: string | null;
}

export interface PhishingTextAnalysis {
  is_phishing: boolean;
  confidence: number;
  label: string;
}

export interface PageContentAiAnalysis extends PhishingTextAnalysis {
  chunkIndex: number; // Indeks analizowanego fragmentu
  originalChunk: string; // Fragment tekstu, który był analizowany
}

export type StoredDomainData = {
  analysis?: DomainAnalysisDetails;
  urlTextAnalysis?: PhishingTextAnalysis | null; // Zmieniona nazwa dla jasności
  pageContentAnalyses?: PageContentAiAnalysis[] | null; // NOWE: Wyniki analizy treści strony
  lastChecked: number;
  error?: string;
  isLoading?: boolean;
};

